{"_id":"@thirdweb-dev/dynamic-contracts","_rev":"28-9465c67b48943410675bafd50a2b0c55","name":"@thirdweb-dev/dynamic-contracts","description":"Architectural pattern for writing dynamic smart contracts in Solidity","dist-tags":{"next":"1.2.1-1","latest":"1.2.5"},"versions":{"1.0.0":{"name":"@thirdweb-dev/dynamic-contracts","version":"1.0.0","author":{"name":"thirdweb engineering","email":"eng@thirdweb.com"},"license":"MIT","_id":"@thirdweb-dev/dynamic-contracts@1.0.0","maintainers":[{"name":"furqantw","email":"furqan@thirdweb.com"},{"name":"jarrodwatts","email":"jarrodwatts16@gmail.com"},{"name":"yash90","email":"yash@thirdweb.com"},{"name":"nachoiacovino","email":"nacho.iacovino@gmail.com"},{"name":"adam-maj","email":"mr.adam.maj@gmail.com"},{"name":"krishang","email":"krishang@thirdweb.com"},{"name":"abenftlabs","email":"abe@nftlabs.co"},{"name":"jakeloo","email":"jake@nftlabs.co"},{"name":"joaquim-verges","email":"joaquim@thirdweb.com"},{"name":"jnsdls","email":"jonas@thirdweb.com"}],"homepage":"https://thirdweb.com","bugs":{"url":"https://github.com/thirdweb-dev/dynamic-contracts/issues"},"dist":{"shasum":"f5c306bf84098c8a472e898962ae49607df29cc7","tarball":"https://registry.npmjs.org/@thirdweb-dev/dynamic-contracts/-/dynamic-contracts-1.0.0.tgz","fileCount":13,"integrity":"sha512-4hmvTIt9niJKjSfwIiz2uNnceQXK7nkRy65YY4k3ppxKgielG+D0IDTwVf4YpKambO6jc2lnSOlHf9uy83kFYg==","signatures":[{"sig":"MEUCIQCSP2XO3DaqSus6VQfLEcNvjFCCfNEgqupUtZQaNAqttQIgG/CFCbP9r7v5RFIrPtPiDCenZ0OFAwqSMIYSDYZ5Feg=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":42439,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJj9l9oACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmq3jQ/+M05qvShJs5OkfezL9ErThrGuBrEObMn/UgpwTewA6ppBr2aR\r\n5soOOj9ljhw666WRiFCXoLh82uQhoulKUPbTLP7XiITy4CXVcweFiuTBWsFI\r\nWs+Qz4CG9JM/hZ8hH9eOvntBB4jxAuoRZXQCErp/khktxRdMY+Oix4TWZh8F\r\nI4G4mhXpu1GQ5F/LNpuxNzNy/V2va6Ti2/vA9r3EhU/T0dxFoEvOsmdxnq0/\r\nzRCpmV4BN4f2WJAoTe+q5ZUvEldXjuE7zpgUpXgN/FMT1FuP+vcx423HiVpx\r\ntb/NI0fMkIA6y6PVVK3tCJiENfR9xU0id+eFcSvMThaAfX8mBJPu7zcSWXMI\r\nX/NdpQLI+r7PauwGzPGNNk0TEgulfEboWZnyUOv5aY+339zFwJnLAaFKlhHp\r\n7G5MarCaJXj9m5bJZqZOz+qMxB1NjFLSJjxpbmzWOlCkp9MfUAOkMpkZXviw\r\nmf+mObt2vckqCQI29gQfBzWWDWF5eEOpkR2neQbMS+2BWdOgdpdFOOjTBGeP\r\nVCxf4U6CQig0vCZp/BLsEuu0VwuOT1chDFXGOAuw5fe5+s+JUPOJS0s+pnlP\r\naW8vTVBHgFtaI08IJdZ8RhJE3mmwIvDYaaHsSVqV0AYhedqGbCqb1CUx/xYX\r\nh0Z1dFVE4TOurF98HdHH61CLAi7Jzp8jpwA=\r\n=b9Vk\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","gitHead":"fe6237cc6e37d723d8ab603d62dfc19da72b546a","scripts":{},"_npmUser":{"name":"joaquim-verges","email":"joaquim@thirdweb.com"},"repository":{"url":"git+https://github.com/thirdweb-dev/dynamic-contracts.git","type":"git"},"_npmVersion":"8.3.1","description":"Architectural pattern for writing dynamic smart contracts in Solidity","directories":{},"_nodeVersion":"16.14.0","dependencies":{},"publishConfig":{"access":"public"},"_hasShrinkwrap":false,"_npmOperationalInternal":{"tmp":"tmp/dynamic-contracts_1.0.0_1677090664344_0.8138686847974761","host":"s3://npm-registry-packages"}},"1.0.1":{"name":"@thirdweb-dev/dynamic-contracts","version":"1.0.1","author":{"name":"thirdweb engineering","email":"eng@thirdweb.com"},"license":"MIT","_id":"@thirdweb-dev/dynamic-contracts@1.0.1","maintainers":[{"name":"furqantw","email":"furqan@thirdweb.com"},{"name":"jarrodwatts","email":"jarrodwatts16@gmail.com"},{"name":"yash90","email":"yash@thirdweb.com"},{"name":"nachoiacovino","email":"nacho.iacovino@gmail.com"},{"name":"adam-maj","email":"mr.adam.maj@gmail.com"},{"name":"krishang","email":"krishang@thirdweb.com"},{"name":"abenftlabs","email":"abe@nftlabs.co"},{"name":"jakeloo","email":"jake@nftlabs.co"},{"name":"joaquim-verges","email":"joaquim@thirdweb.com"},{"name":"jnsdls","email":"jonas@thirdweb.com"}],"homepage":"https://thirdweb.com/","bugs":{"url":"https://github.com/thirdweb-dev/dynamic-contracts/issues"},"dist":{"shasum":"e89514aadd6cf334f593540d84988e970c9e6375","tarball":"https://registry.npmjs.org/@thirdweb-dev/dynamic-contracts/-/dynamic-contracts-1.0.1.tgz","fileCount":84,"integrity":"sha512-YYfOA9tlgWt/yO/xCPpnBxMS+x9WQdd6I98k7cH98TtT0wbgoe2adFkZLNu3Jlq61fTeD3thjEiFVL1u55PNXQ==","signatures":[{"sig":"MEYCIQCtysWGnc2x5lHXnjt1U9n2Fk7l74EWQSz+qpEAIrvhKwIhAIsiLD3idAnrO9+phkFEYp391tR9pThAL+XNpGtHPgfZ","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":2144378,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJj/oa0ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrJSQ/9FB+cO5fSbuNsTii3wXRRTdaY9zL3vC2ojlH3ZYtLLVFe6/WZ\r\nIaojXelg0LfRnDqogTzAQoog2i+h/YWpuk5vZzBmcZ+q57wUsIfrKLXWaPso\r\nirxMdKKbMEPSEyfHMw6sEEvLvgUgdi3eVrwIMEIaQvLQBfgoYJi1Cx6A5UHm\r\nAQrriz03LyhS7BCmfUXkOnaCo0DANqo/c99RSPa8Fyiln2HFwvT8Ve75U3B1\r\nFL07+iXWmxAn20r9EeuK0Qv7ws2xHA2myNM9w63cK9Ih3JtaJf8u8riAqobx\r\nA1uXz4s/aPJbVXD8BxdPrkAzAQOw8/rXZMRY4UWDATqXs/VGjOXlR9hOLt8r\r\nbGr9euIhU4Q76mOG3vDG72bPXuEY176LCqNoTQJkEAqqQ4HhyJTAyfUSBXKF\r\nDbgmB8ycv6CWyIHTCk+6I1ByiJqwkfcSjyORNIsWpUEYCTNfyTRFY2mZdFCq\r\nV4yGFMGI/rni4N+e9BO98d2XTM5J4IevV0IaUz6r5YRdXV0+0Jetq5yW/ON7\r\nhvQoSEBKTUamRihPhAQzTNjS/XmcEn93yLKrxuzBsxdc8E4P54zayiMV6ymF\r\n9QJnKwF2Knigl+aHlGNI1n/+I6R4s9KA9uBetU592BOau5knX6Zvf/hKB8wU\r\n0suojs/qW+CIuhM4TKoE0JmiIzpWrW6fRQI=\r\n=4GV/\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","scripts":{},"_npmUser":{"name":"yash90","email":"yash@thirdweb.com"},"repository":{"url":"https://github.com/thirdweb-dev/dynamic-contracts.git","type":"git"},"description":"Architectural pattern for writing dynamic smart contracts in Solidity","directories":{},"dependencies":{},"publishConfig":{"access":"public"},"_hasShrinkwrap":false,"_npmOperationalInternal":{"tmp":"tmp/dynamic-contracts_1.0.1_1677625012407_0.6150082702893971","host":"s3://npm-registry-packages"}},"1.0.2":{"name":"@thirdweb-dev/dynamic-contracts","version":"1.0.2","author":{"name":"thirdweb engineering","email":"eng@thirdweb.com"},"license":"MIT","_id":"@thirdweb-dev/dynamic-contracts@1.0.2","maintainers":[{"name":"furqantw","email":"furqan@thirdweb.com"},{"name":"jarrodwatts","email":"jarrodwatts16@gmail.com"},{"name":"yash90","email":"yash@thirdweb.com"},{"name":"nachoiacovino","email":"nacho.iacovino@gmail.com"},{"name":"adam-maj","email":"mr.adam.maj@gmail.com"},{"name":"krishang","email":"krishang@thirdweb.com"},{"name":"abenftlabs","email":"abe@nftlabs.co"},{"name":"jakeloo","email":"jake@nftlabs.co"},{"name":"joaquim-verges","email":"joaquim@thirdweb.com"},{"name":"jnsdls","email":"jonas@thirdweb.com"}],"homepage":"https://thirdweb.com/","bugs":{"url":"https://github.com/thirdweb-dev/dynamic-contracts/issues"},"dist":{"shasum":"aa278f5461e64c623d81ba29e3d63d2a71c39e42","tarball":"https://registry.npmjs.org/@thirdweb-dev/dynamic-contracts/-/dynamic-contracts-1.0.2.tgz","fileCount":92,"integrity":"sha512-qKhAD7qogf+zQhSXDJsWvwTxUHGZ3osTYb43bb5j47egk8ybI7RV8Z2l/0kVySOpKUZ048gsyuFsE8Ci3b2csA==","signatures":[{"sig":"MEYCIQCFFHNh47luqg6JMsJHzYMArDnbkYxYdIwfB2T6qai93AIhAJvDqTYVsn4DVeTDW8DC0lFEZRsM1FO+Bb8liZ0h2Ei4","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":2208424,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJkAPzzACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoJiA/+JqFiQj/g8ZX2lBT08UtsLmcDhPU6I4RgkMvwPgEzzV+sEpIQ\r\nt86oqbN4pUK2wvVyivSwC5trMyeyryd7ztwuM8svLSoJbwo4giCWATJyzREV\r\nWyRbZTZ9NchMX+oJgU7RDhutESB0vqtFj7rKyClJyaidXnUM0578zwQv9Inc\r\nfMgynCEzTe9JOLmTP8sRhWA0Q+vXB+unCzbqhiiA8LiO+elgV234ybqC+RDF\r\nID2iYhEYEYe98yukD5XdxHzdvsumpxaIWrjxOgrRcmNGBBiROasVglZ7zzcy\r\nfwiLldlKc4IeutMCX0ajjHgO6ta9ULK+4ksjVnpEU3mxVx/DBID9hdQX0skA\r\nacmofI3FGcdaBWWd6flsI9BeOYdyvEaOqYFCVsas6idcQFiRCKtuSnqwVlWo\r\nyL6UFchYTvyT9GpViAMdv6hSheDNn8Xxpo1cWBC3e9oi2m/DE3oDNw29C8Dh\r\nWoMNBr6t9dT3eC3exoc+No0/Q8hY5Y5lnT1eVcEh3KQy2QYuktVMqvBlqW2Q\r\nZRrsbgfmwT+2LRtyiF2H96RmB/3K9MTuuXnz3g5BdhGkEm8ZP1ORi5ZYyqD+\r\nzOPkKlOnOTyDvEXcPcorgIbFkJN3Ud7+QmmUm6mQb50geu8j7bei+GpIckRB\r\nshK9bnCmfpOSI1w7/AEZLWsuGN7xfpDYEKY=\r\n=l+P3\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","scripts":{},"_npmUser":{"name":"yash90","email":"yash@thirdweb.com"},"repository":{"url":"https://github.com/thirdweb-dev/dynamic-contracts.git","type":"git"},"description":"Architectural pattern for writing dynamic smart contracts in Solidity","directories":{},"dependencies":{},"publishConfig":{"access":"public"},"_hasShrinkwrap":false,"_npmOperationalInternal":{"tmp":"tmp/dynamic-contracts_1.0.2_1677786355198_0.8737648234152382","host":"s3://npm-registry-packages"}},"1.0.4":{"name":"@thirdweb-dev/dynamic-contracts","version":"1.0.4","author":{"name":"thirdweb engineering","email":"eng@thirdweb.com"},"license":"MIT","_id":"@thirdweb-dev/dynamic-contracts@1.0.4","maintainers":[{"name":"furqantw","email":"furqan@thirdweb.com"},{"name":"jarrodwatts","email":"jarrodwatts16@gmail.com"},{"name":"yash90","email":"yash@thirdweb.com"},{"name":"nachoiacovino","email":"nacho.iacovino@gmail.com"},{"name":"adam-maj","email":"mr.adam.maj@gmail.com"},{"name":"krishang","email":"krishang@thirdweb.com"},{"name":"abenftlabs","email":"abe@nftlabs.co"},{"name":"jakeloo","email":"jake@nftlabs.co"},{"name":"joaquim-verges","email":"joaquim@thirdweb.com"},{"name":"jnsdls","email":"jonas@thirdweb.com"}],"homepage":"https://thirdweb.com/","bugs":{"url":"https://github.com/thirdweb-dev/dynamic-contracts/issues"},"dist":{"shasum":"519aa581ed995e1cc3cf3addd1a61c485e735da7","tarball":"https://registry.npmjs.org/@thirdweb-dev/dynamic-contracts/-/dynamic-contracts-1.0.4.tgz","fileCount":158,"integrity":"sha512-EKV3xu+Z4UEN4/hNW7vyuJeMvQZdLNmewYSu2bAohgTpBYw7tDUxMBLqLYwMs4GG/xzA1WYU7mSCVH6kKSH41Q==","signatures":[{"sig":"MEQCIFrpCeOtfjF9+no/ksI3kIXnBs6YZ2veOsQPo4OXgmsBAiA+onOoJXoRpuzOj8cA1iAJoUePotewLETjjQc+9H4sVQ==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":24795665},"main":"index.js","scripts":{},"_npmUser":{"name":"krishang","email":"krishang@thirdweb.com"},"repository":{"url":"https://github.com/thirdweb-dev/dynamic-contracts.git","type":"git"},"description":"Architectural pattern for writing dynamic smart contracts in Solidity","directories":{},"dependencies":{},"publishConfig":{"access":"public"},"_hasShrinkwrap":false,"_npmOperationalInternal":{"tmp":"tmp/dynamic-contracts_1.0.4_1692128569203_0.0854026980120055","host":"s3://npm-registry-packages"}},"1.1.0":{"name":"@thirdweb-dev/dynamic-contracts","version":"1.1.0","author":{"name":"thirdweb engineering","email":"eng@thirdweb.com"},"license":"MIT","_id":"@thirdweb-dev/dynamic-contracts@1.1.0","maintainers":[{"name":"furqantw","email":"furqan@thirdweb.com"},{"name":"jarrodwatts","email":"jarrodwatts16@gmail.com"},{"name":"yash90","email":"yash@thirdweb.com"},{"name":"nachoiacovino","email":"nacho.iacovino@gmail.com"},{"name":"adam-maj","email":"mr.adam.maj@gmail.com"},{"name":"krishang","email":"krishang@thirdweb.com"},{"name":"abenftlabs","email":"abe@nftlabs.co"},{"name":"jakeloo","email":"jake@nftlabs.co"},{"name":"joaquim-verges","email":"joaquim@thirdweb.com"},{"name":"jnsdls","email":"jonas@thirdweb.com"}],"homepage":"https://thirdweb.com/","bugs":{"url":"https://github.com/thirdweb-dev/dynamic-contracts/issues"},"dist":{"shasum":"42bb992f4515b7d9baf8fa1d9b842fbe846eb3f3","tarball":"https://registry.npmjs.org/@thirdweb-dev/dynamic-contracts/-/dynamic-contracts-1.1.0.tgz","fileCount":161,"integrity":"sha512-Nr+vACp6dAfDA4QY3WWODQBOs+km5VKTqYdAD/kiHX8X4xBPjhg8ZOw4hjq+X+wzo+B3nDQaC54N65lmYB6aaw==","signatures":[{"sig":"MEYCIQC9Z3ZtbKL3XLe1NcnBQDWNkjmSkSU9nJgMPqENdva6egIhANzpNZtVBplf8JvWfO3/Tx9VQ89oa7n6MBKegzvQCNCF","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":24812379},"main":"index.js","scripts":{},"_npmUser":{"name":"krishang","email":"krishang@thirdweb.com"},"repository":{"url":"https://github.com/thirdweb-dev/dynamic-contracts.git","type":"git"},"description":"Architectural pattern for writing dynamic smart contracts in Solidity","directories":{},"dependencies":{},"publishConfig":{"access":"public"},"_hasShrinkwrap":false,"_npmOperationalInternal":{"tmp":"tmp/dynamic-contracts_1.1.0_1692133600492_0.33298456341248683","host":"s3://npm-registry-packages"}},"1.1.1":{"name":"@thirdweb-dev/dynamic-contracts","version":"1.1.1","author":{"name":"thirdweb engineering","email":"eng@thirdweb.com"},"license":"MIT","_id":"@thirdweb-dev/dynamic-contracts@1.1.1","maintainers":[{"name":"furqantw","email":"furqan@thirdweb.com"},{"name":"jarrodwatts","email":"jarrodwatts16@gmail.com"},{"name":"yash90","email":"yash@thirdweb.com"},{"name":"nachoiacovino","email":"nacho.iacovino@gmail.com"},{"name":"adam-maj","email":"mr.adam.maj@gmail.com"},{"name":"krishang","email":"krishang@thirdweb.com"},{"name":"abenftlabs","email":"abe@nftlabs.co"},{"name":"jakeloo","email":"jake@nftlabs.co"},{"name":"joaquim-verges","email":"joaquim@thirdweb.com"},{"name":"jnsdls","email":"jonas@thirdweb.com"}],"homepage":"https://thirdweb.com/","bugs":{"url":"https://github.com/thirdweb-dev/dynamic-contracts/issues"},"dist":{"shasum":"535a1b4fff9c880daa0c827a88becd801d1104b2","tarball":"https://registry.npmjs.org/@thirdweb-dev/dynamic-contracts/-/dynamic-contracts-1.1.1.tgz","fileCount":161,"integrity":"sha512-wncE8//8dyB9M7nmDN538IeRSuWNCnxhQkPG+nkPdIMM0tNquPlaY8kXuIr1TCrgBEAcl12xdHn5C7HmOcywYg==","signatures":[{"sig":"MEUCIBSn4+a1+jmEb1mJvY7mRpLssr60u4DlW0USMA32LYNiAiEAyyrEX8Pfupqkm+u/ED874E+h1PHjnG0eT1+sHKFBImg=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":24812293},"main":"index.js","scripts":{},"_npmUser":{"name":"krishang","email":"krishang@thirdweb.com"},"repository":{"url":"https://github.com/thirdweb-dev/dynamic-contracts.git","type":"git"},"description":"Architectural pattern for writing dynamic smart contracts in Solidity","directories":{},"dependencies":{},"publishConfig":{"access":"public"},"_hasShrinkwrap":false,"_npmOperationalInternal":{"tmp":"tmp/dynamic-contracts_1.1.1_1692315315060_0.653824253314969","host":"s3://npm-registry-packages"}},"1.1.2-0":{"name":"@thirdweb-dev/dynamic-contracts","version":"1.1.2-0","author":{"name":"thirdweb engineering","email":"eng@thirdweb.com"},"license":"MIT","_id":"@thirdweb-dev/dynamic-contracts@1.1.2-0","maintainers":[{"name":"furqantw","email":"furqan@thirdweb.com"},{"name":"jarrodwatts","email":"jarrodwatts16@gmail.com"},{"name":"yash90","email":"yash@thirdweb.com"},{"name":"nachoiacovino","email":"nacho.iacovino@gmail.com"},{"name":"adam-maj","email":"mr.adam.maj@gmail.com"},{"name":"krishang","email":"krishang@thirdweb.com"},{"name":"abenftlabs","email":"abe@nftlabs.co"},{"name":"jakeloo","email":"jake@nftlabs.co"},{"name":"joaquim-verges","email":"joaquim@thirdweb.com"},{"name":"jnsdls","email":"jonas@thirdweb.com"}],"homepage":"https://thirdweb.com/","bugs":{"url":"https://github.com/thirdweb-dev/dynamic-contracts/issues"},"dist":{"shasum":"f0654dfb3ae47ad7401d09384bc53dd8ffd7c9c7","tarball":"https://registry.npmjs.org/@thirdweb-dev/dynamic-contracts/-/dynamic-contracts-1.1.2-0.tgz","fileCount":161,"integrity":"sha512-nb+39wkvqp8oiTESSf6NGNoDdGBB6XivdMZN3xFh8w8rQlek0+d2AVWZcB4Qr9NFOBXvj+wVt9H7KCjUOPpFAg==","signatures":[{"sig":"MEUCIQCbMW7NMXVE/EmIY1TgDnDE7C2iCu0hNXI7TZWugO8MugIgI+1+0peSHH2l+1MhGeTJH1tbZ7cQVncGVFTkfhPJD60=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":24805480},"main":"index.js","readme":"# Dynamic Contracts Standard\n\n### Architectural pattern for writing dynamic smart contracts in Solidity\n\nThis repository provides core interfaces and preset implementations that:\n\n- Provide guardrails for writing dynamic contracts that can have functionality added, updated or removed over time\n- Enables scaling up contracts by eliminating the restriction of contract size limit altogether\n\n> This architecture builds upon the diamond pattern ([EIP-2535](https://eips.ethereum.org/EIPS/eip-2535)). We've taken inspiration from it, and boiled it down to its leanest, simplest form.\n\n## Installation\n\n#### Forge\n\n```bash\nforge install https://github.com/thirdweb-dev/dynamic-contracts\n```\n\n#### Hardhat\n\n```bash\nnpm install @thirdweb-dev/dynamic-contracts\n```\n\n## Core concepts\n\n- A `Router` contract can route function calls to any number of destination contracts\n- We call these destination contracts `Extensions`.\n- `Extensions` can be added/updated/removed at any time, according to a predefined set of rules.\n\n![router-pattern](/docs/img/router-diagram.png)\n\n## Getting started\n\n### 1. `Router` - the entrypoint contract\n\nThe simplest way to write a `Router` contract is to extend the preset [`BaseRouter`](/src/presets/BaseRouter.sol) available in this repository.\n\n```solidity\nimport \"lib/dynamic-contracts/src/presets/BaseRouter.sol\";\n```\n\nThe `BaseRouter` contract comes with an API to add/update/remove extensions from the contract. It is an abstract contract, and expects its consumer to implement the `_canSetExtension(...)` function, which specifies the conditions under which `Extensions` can be added, updated or removed. The rest of the implementation is generic and usable for all purposes.\n\n```solidity\nfunction _canSetExtension(Extension memory _extension) internal view virtual returns (bool);\n```\n\nHere's a very simple example that allows only the original contract deployer to add/update/remove `Extensions`.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"lib/dynamic-contracts/src/presets/BaseRouter.sol\";\n\n/// Example usage of `BaseRouter`, for demonstration only\n\ncontract SimpleRouter is BaseRouter {\n\n    address public deployer;\n\n    constructor(Extension[] memory _extensions) BaseRouter(_extensions) {\n        deployer = msg.sender;\n    }\n\n    /// @dev Returns whether extensions can be set in the given execution context.\n    function _canSetExtension(Extension memory _extension) internal view virtual override returns (bool) {\n        return msg.sender == deployer;\n    }\n}\n```\n\n#### Choosing a permission model:\n\nThe main decision as a `Router` contract author is to decide the permission model to add/update/remove extensions. This repository offers some presets for a few possible permission models:\n\n- #### [`RouterUpgradeable`](/src/presets/example/RouterUpgradeable.sol)\n\nThis a is a preset that **allows the contract owner to add / upgrade / remove extensions**. The contract owner can be changed. This is a very basic permission model, but enough for some use cases. You can expand on this and use a permission based model instead for example.\n\n- #### [`RouterImmutable`](/src/presets/example/RouterImmutable.sol)\n\nThis is a preset you can use to **create static contracts that cannot be updated or get new functionality**. This still allows you to create modular contracts that go beyond the contract size limit, but guarantees that the original functionality cannot be altered. With this model, you would pass all the `Extensions` for this contract at construction time, and guarantee that the functionality is immutable.\n\nOther permissions models might include an explicit list of extensions that can be added or removed for example. The implementation is up to the Router author.\n\n- #### [`RouterRegistryConstrained`](/src/presets/example/RouterRegistryConstrained.sol)\n\nThis is a preset that **allows the owner to change extensions if they are defined on a given registry contract**. This is meant to demonstrate how a protocol ecosystem could constrain extensions to known, audited contracts, for instance. The registry and router upgrade models are of course too basic for production as written.\n\n### 2. `Extensions` - implementing routeable contracts\n\nAn `Extension` contract is written like any other smart contract, except that its state must be defined using a `struct` within a `library` and at a well defined storage location. This storage technique is known as [storage structs](https://mirror.xyz/horsefacts.eth/EPB4o-eyDl0N8gu0gEz1uw7BTITheaZUqIAOEK1m-jE). This is important to ensure that state defined in an `Extension` doesn't conflict with the state of another `Extension` of the same `Router` at the same storage location.\n\nHere's an example of a simple contract written as an `Extension` contract:\n\n```solidity\n\n/// library defining the data structure of our contract\nlibrary NumberStorage {\n    /// specify the storage location, needs to be unique\n    bytes32 public constant NUMBER_STORAGE_POSITION = keccak256(\"number.storage\");\n\n    /// the state data struct\n    struct Data {\n        uint256 number;\n    }\n\n    /// state accessor, always use this to access the state data\n    function numberStorage() internal pure returns (Data storage numberData) {\n        bytes32 position = NUMBER_STORAGE_POSITION;\n        assembly {\n            numberData.slot := position\n        }\n    }\n}\n\n/// implementation of our contract's logic, notice the lack of local state\n/// state is always accessed via the storage library defined above\ncontract Number {\n\n    function setNumber(uint256 _newNumber) external {\n        NumberStorage.Data storage data = NumberStorage.numberStorage();\n        data.number = _newNumber;\n    }\n\n    function getNumber() external view returns (uint256) {\n        NumberStorage.Data storage data = NumberStorage.numberStorage();\n        return data.number;\n    }\n}\n```\n\nTo compare, here is the same contract written in a regular way:\n\n```solidity\ncontract Number {\n\n    uint256 private number;\n\n    function setNumber(uint256 _newNumber) external {\n        number = _newNumber;\n    }\n\n    function getNumber() external view returns (uint256) {\n        return number;\n    }\n}\n```\n\nThe main difference is how the state is defined. While an `Extension` written this way requires a bit more boilerplate to setup, it is a one time cost that ensures full modularity when using multiple `Extension` contracts with a single `Router`.\n\n### 3. Deploying a `Router`\n\nDeploying a contract in the router pattern looks a little different from deploying a regular contract.\n\n1. Deploy all your `Extension` contracts first. You only need to do this once per `Extension`. Deployed `Extensions` can be re-used by many different `Router` contracts.\n\n2. Deploy your `Router` contract that implements `BaseRouter`.\n\n3. Optionally, you pass your default `Extensions` in the constructor of your `BaseRouter` at deploy time. This is a convenient way to bootstrap an `Router` with a set of default `Extension` in one transaction.\n\n### 4. Adding, removing or upgrading `Extensions` post deployment\n\nThe preset `BaseRouter` comes with an API to add/update/remove `Extensions` at any time after deployment:\n\n- `addExtension()`: function to add completely new `Extension` to your `Router`.\n- `updateExtension()`: function to update the address, metadata, or functions of an existing `Extension` in your `Router`.\n- `removeExtension()`: remove an existing `Extension` from your `Router`.\n\nThe permission to modify `Extensions` is encoded in your `Router` and can have different conditions.\n\nWith this pattern, your contract is now dynamically updeatable, with granular control.\n\n- Add entire new functionality to your contract post deployment\n- Remove functionality when it's not longer needed\n- Deploy security and bug fixes for a single function of your contract\n\n---\n\n## Going deeper - background and technical details\n\nIn the standard proxy pattern for smart contracts, a proxy smart contract calls a _logic contract_ using `delegateCall`. This allows proxies to keep a persistent state (storage and balance) while the code is delegated to the logic contract. ([EIP-1967](https://eips.ethereum.org/EIPS/eip-1967))\n\nThe pattern aims to solve for the following two limitations of this standard proxy pattern:\n\n1. The proxy contract points to a single smart contract as its _logic contract_, at a time.\n2. The _logic contract_ is subject to the smart contract size limit of ~24kb ([EIP-170](https://eips.ethereum.org/EIPS/eip-170)). This prevents a single smart contract from having all of the features one may want it to have.\n\n> **Note:** The diamond pattern ([EIP-2535](https://eips.ethereum.org/EIPS/eip-2535)) anticipates these same problems and more. We've taken inspiration from it, and boiled it down to its leanest, simplest form.\n\nThe router pattern eliminates these limitations performing a lookup for the implementation smart contract address associated with every incoming function call, and make a `delegateCall` to that particular implementation.\n\nThis is different from the standard proxy pattern, where the proxy stores a single implementation smart contract address, and calls via `delegateCall` this same implementation for every incoming function call.\n\n**Standard proxy pattern**\n\n```solidity\ncontract StandardProxy {\n\n  address public constant implementation = 0xabc...;\n\n  fallback() external payable virtual {\n    _delegateCall(implementation);\n  }\n}\n```\n\n**Router pattern**\n\n```solidity\nabstract contract Router {\n\n  fallback() external payable virtual {\n    address implementation = getImplementationForFunction(msg.sig);\n    _delegateCall(implementation);\n  }\n\n  function getImplementationForFunction(bytes4 _functionSelector) public view virtual returns (address);\n}\n```\n\nThis setup in the `Router` contract allows for different functions of the smart contract to be implemented in different logic contracts.\n\n### `Extensions` - Grouping logical functionality together\n\nBy itself, the core `Router` contract does not specify _how to store or fetch_ appropriate implementation addresses for incoming function calls.\n\nWhile the Router pattern allows to point to a different contract for each function, in practice functions are usually groupped by functionality related to a shared state (a read and a set function for example).\n\nTo make the pattern more practical, we created a generic `BaseRouter` contract that makes it easy to have logical group of functions plugged in and out of it, each group of functions being implemented in a separate implementation contract. We refer to each such implementation contract as an **_extension_**.\n\n`BaseRouter` maintains a `function_signature` → `implementation` mapping, and provides an API for updating that mapping. By updating the values stored in this map, functionality can be added to, removed from or updated in the smart contract.\n\n![updating-extensions](/docs/img/update-diagram.png)\n\n### `Extension` to `Extension` communication\n\nWhen splitting logic between multiple `Extensions` in a `Router`, one might want to access data from one `Extension` to another.\n\nA simple way to do this is by casting the current contract address as the `Extension` (ideally its interface) we're trying to call. This works from both a `Router` or any of its `Extensions`.\n\nHere's an example of accessing a IPermission `Extension` from another one:\n\n```solidity\n/// in MyExtension.sol\nmodifier onlyAdmin(address _asset) {\n  /// we access our IPermission extension by casting our own address\n  IPermissions(address(this)).hasAdminRole(msg.sender);\n}\n```\n\nNote that if we don't have a IPermission `Extension` added to our `Router`, this method will revert.\n\n### Upgrading `Extensions`\n\nJust like any upgradeable contract, there are limitations on how the data structure of the updated contract is modified. While the logic of a function can be updated safely, changing the data structure of a contract requires careful consideration.\n\nA good rule of thumb to follow is:\n\n- It is safe to append new fields to an existing data structure\n- It is _not_ safe to update the type or order of existing structs, deprecate and add new ones instead\n\nRefer to [this article](https://mirror.xyz/horsefacts.eth/EPB4o-eyDl0N8gu0gEz1uw7BTITheaZUqIAOEK1m-jE) for more information.\n\n## Feedback\n\nThe best, most open way to give feedback/suggestions for the router pattern is to open a github issue.\n\nAdditionally, since [thirdweb](https://thirdweb.com/) will be maintaining this repository, you can reach out to us at support@thirdweb.com or join our [discord](https://discord.gg/thirdweb).\n\n## Authors\n\n- [thirdweb](https://github.com/thirdweb-dev)\n","scripts":{},"_npmUser":{"name":"krishang","email":"krishang@thirdweb.com"},"repository":{"url":"https://github.com/thirdweb-dev/dynamic-contracts.git","type":"git"},"description":"Architectural pattern for writing dynamic smart contracts in Solidity","directories":{},"dependencies":{},"publishConfig":{"access":"public"},"_hasShrinkwrap":false,"readmeFilename":"README.md","_npmOperationalInternal":{"tmp":"tmp/dynamic-contracts_1.1.2-0_1692316836916_0.71731204150306","host":"s3://npm-registry-packages"}},"1.1.2":{"name":"@thirdweb-dev/dynamic-contracts","version":"1.1.2","author":{"name":"thirdweb engineering","email":"eng@thirdweb.com"},"license":"MIT","_id":"@thirdweb-dev/dynamic-contracts@1.1.2","maintainers":[{"name":"furqantw","email":"furqan@thirdweb.com"},{"name":"jarrodwatts","email":"jarrodwatts16@gmail.com"},{"name":"yash90","email":"yash@thirdweb.com"},{"name":"nachoiacovino","email":"nacho.iacovino@gmail.com"},{"name":"adam-maj","email":"mr.adam.maj@gmail.com"},{"name":"krishang","email":"krishang@thirdweb.com"},{"name":"abenftlabs","email":"abe@nftlabs.co"},{"name":"jakeloo","email":"jake@nftlabs.co"},{"name":"joaquim-verges","email":"joaquim@thirdweb.com"},{"name":"jnsdls","email":"jonas@thirdweb.com"}],"homepage":"https://thirdweb.com/","bugs":{"url":"https://github.com/thirdweb-dev/dynamic-contracts/issues"},"dist":{"shasum":"9a7ff4d9e7f5f9f4eac96e21b0eabdd52c95f3ef","tarball":"https://registry.npmjs.org/@thirdweb-dev/dynamic-contracts/-/dynamic-contracts-1.1.2.tgz","fileCount":161,"integrity":"sha512-ZTVpWPZcF8BDMHYFfpLo3vjrVR0QgQe1AUTd+1uq/gtdYG/DB8dZBCfmR4wnOnkUQDvLLtIOc4PqpqyccVL2vQ==","signatures":[{"sig":"MEUCIDmVa78UV0luLdflmFvAi2DNF4979m4GVlAlIGeadABKAiEA2dnstVJpUySX91e/B9gLZRQn3qvB1FoO8aetrPAceek=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":24805478},"main":"index.js","scripts":{},"_npmUser":{"name":"krishang","email":"krishang@thirdweb.com"},"repository":{"url":"https://github.com/thirdweb-dev/dynamic-contracts.git","type":"git"},"description":"Architectural pattern for writing dynamic smart contracts in Solidity","directories":{},"dependencies":{},"publishConfig":{"access":"public"},"_hasShrinkwrap":false,"_npmOperationalInternal":{"tmp":"tmp/dynamic-contracts_1.1.2_1692317539362_0.3095148470868361","host":"s3://npm-registry-packages"}},"1.1.3-0":{"name":"@thirdweb-dev/dynamic-contracts","version":"1.1.3-0","author":{"name":"thirdweb engineering","email":"eng@thirdweb.com"},"license":"MIT","_id":"@thirdweb-dev/dynamic-contracts@1.1.3-0","maintainers":[{"name":"furqantw","email":"furqan@thirdweb.com"},{"name":"jarrodwatts","email":"jarrodwatts16@gmail.com"},{"name":"yash90","email":"yash@thirdweb.com"},{"name":"nachoiacovino","email":"nacho.iacovino@gmail.com"},{"name":"adam-maj","email":"mr.adam.maj@gmail.com"},{"name":"krishang","email":"krishang@thirdweb.com"},{"name":"abenftlabs","email":"abe@nftlabs.co"},{"name":"jakeloo","email":"jake@nftlabs.co"},{"name":"joaquim-verges","email":"joaquim@thirdweb.com"},{"name":"jnsdls","email":"jonas@thirdweb.com"}],"homepage":"https://thirdweb.com/","bugs":{"url":"https://github.com/thirdweb-dev/dynamic-contracts/issues"},"dist":{"shasum":"edca953f7df703ecc582b2b21a36fe17a54bb7b7","tarball":"https://registry.npmjs.org/@thirdweb-dev/dynamic-contracts/-/dynamic-contracts-1.1.3-0.tgz","fileCount":161,"integrity":"sha512-L6eSdFPmoTlBlknTluyLhyDptfAbUydebQTzWcsaOw5vkfFPDjKJlPJy1cKWdRGQQRhf2fYzssXvm1p4HtFDCQ==","signatures":[{"sig":"MEUCIFiudq1dMrQoPhi+q3USFhdH7GJrRisYOE+aofzBVf6bAiEA+2qmTzeBtGE3QVuVziaDYUGQcsR5akwAp6LVzwh2aNg=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":24806630},"main":"index.js","readme":"# Dynamic Contracts Standard\n\n### Architectural pattern for writing dynamic smart contracts in Solidity\n\nThis repository provides core interfaces and preset implementations that:\n\n- Provide guardrails for writing dynamic contracts that can have functionality added, updated or removed over time\n- Enables scaling up contracts by eliminating the restriction of contract size limit altogether\n\n> This architecture builds upon the diamond pattern ([EIP-2535](https://eips.ethereum.org/EIPS/eip-2535)). We've taken inspiration from it, and boiled it down to its leanest, simplest form.\n\n## Installation\n\n#### Forge\n\n```bash\nforge install https://github.com/thirdweb-dev/dynamic-contracts\n```\n\n#### Hardhat\n\n```bash\nnpm install @thirdweb-dev/dynamic-contracts\n```\n\n## Core concepts\n\n- A `Router` contract can route function calls to any number of destination contracts\n- We call these destination contracts `Extensions`.\n- `Extensions` can be added/updated/removed at any time, according to a predefined set of rules.\n\n![router-pattern](/docs/img/router-diagram.png)\n\n## Getting started\n\n### 1. `Router` - the entrypoint contract\n\nThe simplest way to write a `Router` contract is to extend the preset [`BaseRouter`](/src/presets/BaseRouter.sol) available in this repository.\n\n```solidity\nimport \"lib/dynamic-contracts/src/presets/BaseRouter.sol\";\n```\n\nThe `BaseRouter` contract comes with an API to add/update/remove extensions from the contract. It is an abstract contract, and expects its consumer to implement the `_canSetExtension(...)` function, which specifies the conditions under which `Extensions` can be added, updated or removed. The rest of the implementation is generic and usable for all purposes.\n\n```solidity\nfunction _canSetExtension(Extension memory _extension) internal view virtual returns (bool);\n```\n\nHere's a very simple example that allows only the original contract deployer to add/update/remove `Extensions`.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"lib/dynamic-contracts/src/presets/BaseRouter.sol\";\n\n/// Example usage of `BaseRouter`, for demonstration only\n\ncontract SimpleRouter is BaseRouter {\n\n    address public deployer;\n\n    constructor(Extension[] memory _extensions) BaseRouter(_extensions) {\n        deployer = msg.sender;\n    }\n\n    /// @dev Returns whether extensions can be set in the given execution context.\n    function _canSetExtension(Extension memory _extension) internal view virtual override returns (bool) {\n        return msg.sender == deployer;\n    }\n}\n```\n\n#### Choosing a permission model:\n\nThe main decision as a `Router` contract author is to decide the permission model to add/update/remove extensions. This repository offers some presets for a few possible permission models:\n\n- #### [`RouterUpgradeable`](/src/presets/example/RouterUpgradeable.sol)\n\nThis a is a preset that **allows the contract owner to add / upgrade / remove extensions**. The contract owner can be changed. This is a very basic permission model, but enough for some use cases. You can expand on this and use a permission based model instead for example.\n\n- #### [`RouterImmutable`](/src/presets/example/RouterImmutable.sol)\n\nThis is a preset you can use to **create static contracts that cannot be updated or get new functionality**. This still allows you to create modular contracts that go beyond the contract size limit, but guarantees that the original functionality cannot be altered. With this model, you would pass all the `Extensions` for this contract at construction time, and guarantee that the functionality is immutable.\n\nOther permissions models might include an explicit list of extensions that can be added or removed for example. The implementation is up to the Router author.\n\n- #### [`RouterRegistryConstrained`](/src/presets/example/RouterRegistryConstrained.sol)\n\nThis is a preset that **allows the owner to change extensions if they are defined on a given registry contract**. This is meant to demonstrate how a protocol ecosystem could constrain extensions to known, audited contracts, for instance. The registry and router upgrade models are of course too basic for production as written.\n\n### 2. `Extensions` - implementing routeable contracts\n\nAn `Extension` contract is written like any other smart contract, except that its state must be defined using a `struct` within a `library` and at a well defined storage location. This storage technique is known as [storage structs](https://mirror.xyz/horsefacts.eth/EPB4o-eyDl0N8gu0gEz1uw7BTITheaZUqIAOEK1m-jE). This is important to ensure that state defined in an `Extension` doesn't conflict with the state of another `Extension` of the same `Router` at the same storage location.\n\nHere's an example of a simple contract written as an `Extension` contract:\n\n```solidity\n\n/// library defining the data structure of our contract\nlibrary NumberStorage {\n    /// specify the storage location, needs to be unique\n    bytes32 public constant NUMBER_STORAGE_POSITION = keccak256(\"number.storage\");\n\n    /// the state data struct\n    struct Data {\n        uint256 number;\n    }\n\n    /// state accessor, always use this to access the state data\n    function numberStorage() internal pure returns (Data storage numberData) {\n        bytes32 position = NUMBER_STORAGE_POSITION;\n        assembly {\n            numberData.slot := position\n        }\n    }\n}\n\n/// implementation of our contract's logic, notice the lack of local state\n/// state is always accessed via the storage library defined above\ncontract Number {\n\n    function setNumber(uint256 _newNumber) external {\n        NumberStorage.Data storage data = NumberStorage.numberStorage();\n        data.number = _newNumber;\n    }\n\n    function getNumber() external view returns (uint256) {\n        NumberStorage.Data storage data = NumberStorage.numberStorage();\n        return data.number;\n    }\n}\n```\n\nTo compare, here is the same contract written in a regular way:\n\n```solidity\ncontract Number {\n\n    uint256 private number;\n\n    function setNumber(uint256 _newNumber) external {\n        number = _newNumber;\n    }\n\n    function getNumber() external view returns (uint256) {\n        return number;\n    }\n}\n```\n\nThe main difference is how the state is defined. While an `Extension` written this way requires a bit more boilerplate to setup, it is a one time cost that ensures full modularity when using multiple `Extension` contracts with a single `Router`.\n\n### 3. Deploying a `Router`\n\nDeploying a contract in the router pattern looks a little different from deploying a regular contract.\n\n1. Deploy all your `Extension` contracts first. You only need to do this once per `Extension`. Deployed `Extensions` can be re-used by many different `Router` contracts.\n\n2. Deploy your `Router` contract that implements `BaseRouter`.\n\n3. Optionally, you pass your default `Extensions` in the constructor of your `BaseRouter` at deploy time. This is a convenient way to bootstrap an `Router` with a set of default `Extension` in one transaction.\n\n### 4. Adding, removing or upgrading `Extensions` post deployment\n\nThe preset `BaseRouter` comes with an API to add/update/remove `Extensions` at any time after deployment:\n\n- `addExtension()`: function to add completely new `Extension` to your `Router`.\n- `updateExtension()`: function to update the address, metadata, or functions of an existing `Extension` in your `Router`.\n- `removeExtension()`: remove an existing `Extension` from your `Router`.\n\nThe permission to modify `Extensions` is encoded in your `Router` and can have different conditions.\n\nWith this pattern, your contract is now dynamically updeatable, with granular control.\n\n- Add entire new functionality to your contract post deployment\n- Remove functionality when it's not longer needed\n- Deploy security and bug fixes for a single function of your contract\n\n---\n\n## Going deeper - background and technical details\n\nIn the standard proxy pattern for smart contracts, a proxy smart contract calls a _logic contract_ using `delegateCall`. This allows proxies to keep a persistent state (storage and balance) while the code is delegated to the logic contract. ([EIP-1967](https://eips.ethereum.org/EIPS/eip-1967))\n\nThe pattern aims to solve for the following two limitations of this standard proxy pattern:\n\n1. The proxy contract points to a single smart contract as its _logic contract_, at a time.\n2. The _logic contract_ is subject to the smart contract size limit of ~24kb ([EIP-170](https://eips.ethereum.org/EIPS/eip-170)). This prevents a single smart contract from having all of the features one may want it to have.\n\n> **Note:** The diamond pattern ([EIP-2535](https://eips.ethereum.org/EIPS/eip-2535)) anticipates these same problems and more. We've taken inspiration from it, and boiled it down to its leanest, simplest form.\n\nThe router pattern eliminates these limitations performing a lookup for the implementation smart contract address associated with every incoming function call, and make a `delegateCall` to that particular implementation.\n\nThis is different from the standard proxy pattern, where the proxy stores a single implementation smart contract address, and calls via `delegateCall` this same implementation for every incoming function call.\n\n**Standard proxy pattern**\n\n```solidity\ncontract StandardProxy {\n\n  address public constant implementation = 0xabc...;\n\n  fallback() external payable virtual {\n    _delegateCall(implementation);\n  }\n}\n```\n\n**Router pattern**\n\n```solidity\nabstract contract Router {\n\n  fallback() external payable virtual {\n    address implementation = getImplementationForFunction(msg.sig);\n    _delegateCall(implementation);\n  }\n\n  function getImplementationForFunction(bytes4 _functionSelector) public view virtual returns (address);\n}\n```\n\nThis setup in the `Router` contract allows for different functions of the smart contract to be implemented in different logic contracts.\n\n### `Extensions` - Grouping logical functionality together\n\nBy itself, the core `Router` contract does not specify _how to store or fetch_ appropriate implementation addresses for incoming function calls.\n\nWhile the Router pattern allows to point to a different contract for each function, in practice functions are usually groupped by functionality related to a shared state (a read and a set function for example).\n\nTo make the pattern more practical, we created a generic `BaseRouter` contract that makes it easy to have logical group of functions plugged in and out of it, each group of functions being implemented in a separate implementation contract. We refer to each such implementation contract as an **_extension_**.\n\n`BaseRouter` maintains a `function_signature` → `implementation` mapping, and provides an API for updating that mapping. By updating the values stored in this map, functionality can be added to, removed from or updated in the smart contract.\n\n![updating-extensions](/docs/img/update-diagram.png)\n\n### `Extension` to `Extension` communication\n\nWhen splitting logic between multiple `Extensions` in a `Router`, one might want to access data from one `Extension` to another.\n\nA simple way to do this is by casting the current contract address as the `Extension` (ideally its interface) we're trying to call. This works from both a `Router` or any of its `Extensions`.\n\nHere's an example of accessing a IPermission `Extension` from another one:\n\n```solidity\n/// in MyExtension.sol\nmodifier onlyAdmin(address _asset) {\n  /// we access our IPermission extension by casting our own address\n  IPermissions(address(this)).hasAdminRole(msg.sender);\n}\n```\n\nNote that if we don't have a IPermission `Extension` added to our `Router`, this method will revert.\n\n### Upgrading `Extensions`\n\nJust like any upgradeable contract, there are limitations on how the data structure of the updated contract is modified. While the logic of a function can be updated safely, changing the data structure of a contract requires careful consideration.\n\nA good rule of thumb to follow is:\n\n- It is safe to append new fields to an existing data structure\n- It is _not_ safe to update the type or order of existing structs, deprecate and add new ones instead\n\nRefer to [this article](https://mirror.xyz/horsefacts.eth/EPB4o-eyDl0N8gu0gEz1uw7BTITheaZUqIAOEK1m-jE) for more information.\n\n## Feedback\n\nThe best, most open way to give feedback/suggestions for the router pattern is to open a github issue.\n\nAdditionally, since [thirdweb](https://thirdweb.com/) will be maintaining this repository, you can reach out to us at support@thirdweb.com or join our [discord](https://discord.gg/thirdweb).\n\n## Authors\n\n- [thirdweb](https://github.com/thirdweb-dev)\n","scripts":{},"_npmUser":{"name":"krishang","email":"krishang@thirdweb.com"},"repository":{"url":"https://github.com/thirdweb-dev/dynamic-contracts.git","type":"git"},"description":"Architectural pattern for writing dynamic smart contracts in Solidity","directories":{},"dependencies":{},"publishConfig":{"access":"public"},"_hasShrinkwrap":false,"readmeFilename":"README.md","_npmOperationalInternal":{"tmp":"tmp/dynamic-contracts_1.1.3-0_1692371349471_0.284508735171485","host":"s3://npm-registry-packages"}},"1.1.3-1":{"name":"@thirdweb-dev/dynamic-contracts","version":"1.1.3-1","author":{"name":"thirdweb engineering","email":"eng@thirdweb.com"},"license":"MIT","_id":"@thirdweb-dev/dynamic-contracts@1.1.3-1","maintainers":[{"name":"furqantw","email":"furqan@thirdweb.com"},{"name":"jarrodwatts","email":"jarrodwatts16@gmail.com"},{"name":"yash90","email":"yash@thirdweb.com"},{"name":"nachoiacovino","email":"nacho.iacovino@gmail.com"},{"name":"adam-maj","email":"mr.adam.maj@gmail.com"},{"name":"krishang","email":"krishang@thirdweb.com"},{"name":"abenftlabs","email":"abe@nftlabs.co"},{"name":"jakeloo","email":"jake@nftlabs.co"},{"name":"joaquim-verges","email":"joaquim@thirdweb.com"},{"name":"jnsdls","email":"jonas@thirdweb.com"}],"homepage":"https://thirdweb.com/","bugs":{"url":"https://github.com/thirdweb-dev/dynamic-contracts/issues"},"dist":{"shasum":"97edeb17e23003eed120f0a7c830969c33b578df","tarball":"https://registry.npmjs.org/@thirdweb-dev/dynamic-contracts/-/dynamic-contracts-1.1.3-1.tgz","fileCount":161,"integrity":"sha512-wUadD5bULOf5I7f+Os78YbM89Z7O6cTQNMxeqiJtGqAhNrNQtNxoOhNzfoYPS5Syx5HIempA63uqGr6Ubau2jw==","signatures":[{"sig":"MEUCIQD4EMkn0rtmZcOtEiZpVe08JWS2KorAx2WmyJw7+Y2kjgIgGl/lxOtfw1ZKrmhfb3k4YmQOSFcHHr4Tx8qRvjs30KI=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":24966299},"main":"index.js","readme":"# Dynamic Contracts Standard\n\n### Architectural pattern for writing dynamic smart contracts in Solidity\n\nThis repository provides core interfaces and preset implementations that:\n\n- Provide guardrails for writing dynamic contracts that can have functionality added, updated or removed over time\n- Enables scaling up contracts by eliminating the restriction of contract size limit altogether\n\n> This architecture builds upon the diamond pattern ([EIP-2535](https://eips.ethereum.org/EIPS/eip-2535)). We've taken inspiration from it, and boiled it down to its leanest, simplest form.\n\n## Installation\n\n#### Forge\n\n```bash\nforge install https://github.com/thirdweb-dev/dynamic-contracts\n```\n\n#### Hardhat\n\n```bash\nnpm install @thirdweb-dev/dynamic-contracts\n```\n\n## Core concepts\n\n- A `Router` contract can route function calls to any number of destination contracts\n- We call these destination contracts `Extensions`.\n- `Extensions` can be added/updated/removed at any time, according to a predefined set of rules.\n\n![router-pattern](/docs/img/router-diagram.png)\n\n## Getting started\n\n### 1. `Router` - the entrypoint contract\n\nThe simplest way to write a `Router` contract is to extend the preset [`BaseRouter`](/src/presets/BaseRouter.sol) available in this repository.\n\n```solidity\nimport \"lib/dynamic-contracts/src/presets/BaseRouter.sol\";\n```\n\nThe `BaseRouter` contract comes with an API to add/update/remove extensions from the contract. It is an abstract contract, and expects its consumer to implement the `_canSetExtension(...)` function, which specifies the conditions under which `Extensions` can be added, updated or removed. The rest of the implementation is generic and usable for all purposes.\n\n```solidity\nfunction _canSetExtension(Extension memory _extension) internal view virtual returns (bool);\n```\n\nHere's a very simple example that allows only the original contract deployer to add/update/remove `Extensions`.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"lib/dynamic-contracts/src/presets/BaseRouter.sol\";\n\n/// Example usage of `BaseRouter`, for demonstration only\n\ncontract SimpleRouter is BaseRouter {\n\n    address public deployer;\n\n    constructor(Extension[] memory _extensions) BaseRouter(_extensions) {\n        deployer = msg.sender;\n    }\n\n    /// @dev Returns whether extensions can be set in the given execution context.\n    function _canSetExtension(Extension memory _extension) internal view virtual override returns (bool) {\n        return msg.sender == deployer;\n    }\n}\n```\n\n#### Choosing a permission model:\n\nThe main decision as a `Router` contract author is to decide the permission model to add/update/remove extensions. This repository offers some presets for a few possible permission models:\n\n- #### [`RouterUpgradeable`](/src/presets/example/RouterUpgradeable.sol)\n\nThis a is a preset that **allows the contract owner to add / upgrade / remove extensions**. The contract owner can be changed. This is a very basic permission model, but enough for some use cases. You can expand on this and use a permission based model instead for example.\n\n- #### [`RouterImmutable`](/src/presets/example/RouterImmutable.sol)\n\nThis is a preset you can use to **create static contracts that cannot be updated or get new functionality**. This still allows you to create modular contracts that go beyond the contract size limit, but guarantees that the original functionality cannot be altered. With this model, you would pass all the `Extensions` for this contract at construction time, and guarantee that the functionality is immutable.\n\nOther permissions models might include an explicit list of extensions that can be added or removed for example. The implementation is up to the Router author.\n\n- #### [`RouterRegistryConstrained`](/src/presets/example/RouterRegistryConstrained.sol)\n\nThis is a preset that **allows the owner to change extensions if they are defined on a given registry contract**. This is meant to demonstrate how a protocol ecosystem could constrain extensions to known, audited contracts, for instance. The registry and router upgrade models are of course too basic for production as written.\n\n### 2. `Extensions` - implementing routeable contracts\n\nAn `Extension` contract is written like any other smart contract, except that its state must be defined using a `struct` within a `library` and at a well defined storage location. This storage technique is known as [storage structs](https://mirror.xyz/horsefacts.eth/EPB4o-eyDl0N8gu0gEz1uw7BTITheaZUqIAOEK1m-jE). This is important to ensure that state defined in an `Extension` doesn't conflict with the state of another `Extension` of the same `Router` at the same storage location.\n\nHere's an example of a simple contract written as an `Extension` contract:\n\n```solidity\n\n/// library defining the data structure of our contract\nlibrary NumberStorage {\n    /// specify the storage location, needs to be unique\n    bytes32 public constant NUMBER_STORAGE_POSITION = keccak256(\"number.storage\");\n\n    /// the state data struct\n    struct Data {\n        uint256 number;\n    }\n\n    /// state accessor, always use this to access the state data\n    function numberStorage() internal pure returns (Data storage numberData) {\n        bytes32 position = NUMBER_STORAGE_POSITION;\n        assembly {\n            numberData.slot := position\n        }\n    }\n}\n\n/// implementation of our contract's logic, notice the lack of local state\n/// state is always accessed via the storage library defined above\ncontract Number {\n\n    function setNumber(uint256 _newNumber) external {\n        NumberStorage.Data storage data = NumberStorage.numberStorage();\n        data.number = _newNumber;\n    }\n\n    function getNumber() external view returns (uint256) {\n        NumberStorage.Data storage data = NumberStorage.numberStorage();\n        return data.number;\n    }\n}\n```\n\nTo compare, here is the same contract written in a regular way:\n\n```solidity\ncontract Number {\n\n    uint256 private number;\n\n    function setNumber(uint256 _newNumber) external {\n        number = _newNumber;\n    }\n\n    function getNumber() external view returns (uint256) {\n        return number;\n    }\n}\n```\n\nThe main difference is how the state is defined. While an `Extension` written this way requires a bit more boilerplate to setup, it is a one time cost that ensures full modularity when using multiple `Extension` contracts with a single `Router`.\n\n### 3. Deploying a `Router`\n\nDeploying a contract in the router pattern looks a little different from deploying a regular contract.\n\n1. Deploy all your `Extension` contracts first. You only need to do this once per `Extension`. Deployed `Extensions` can be re-used by many different `Router` contracts.\n\n2. Deploy your `Router` contract that implements `BaseRouter`.\n\n3. Optionally, you pass your default `Extensions` in the constructor of your `BaseRouter` at deploy time. This is a convenient way to bootstrap an `Router` with a set of default `Extension` in one transaction.\n\n### 4. Adding, removing or upgrading `Extensions` post deployment\n\nThe preset `BaseRouter` comes with an API to add/update/remove `Extensions` at any time after deployment:\n\n- `addExtension()`: function to add completely new `Extension` to your `Router`.\n- `updateExtension()`: function to update the address, metadata, or functions of an existing `Extension` in your `Router`.\n- `removeExtension()`: remove an existing `Extension` from your `Router`.\n\nThe permission to modify `Extensions` is encoded in your `Router` and can have different conditions.\n\nWith this pattern, your contract is now dynamically updeatable, with granular control.\n\n- Add entire new functionality to your contract post deployment\n- Remove functionality when it's not longer needed\n- Deploy security and bug fixes for a single function of your contract\n\n---\n\n## Going deeper - background and technical details\n\nIn the standard proxy pattern for smart contracts, a proxy smart contract calls a _logic contract_ using `delegateCall`. This allows proxies to keep a persistent state (storage and balance) while the code is delegated to the logic contract. ([EIP-1967](https://eips.ethereum.org/EIPS/eip-1967))\n\nThe pattern aims to solve for the following two limitations of this standard proxy pattern:\n\n1. The proxy contract points to a single smart contract as its _logic contract_, at a time.\n2. The _logic contract_ is subject to the smart contract size limit of ~24kb ([EIP-170](https://eips.ethereum.org/EIPS/eip-170)). This prevents a single smart contract from having all of the features one may want it to have.\n\n> **Note:** The diamond pattern ([EIP-2535](https://eips.ethereum.org/EIPS/eip-2535)) anticipates these same problems and more. We've taken inspiration from it, and boiled it down to its leanest, simplest form.\n\nThe router pattern eliminates these limitations performing a lookup for the implementation smart contract address associated with every incoming function call, and make a `delegateCall` to that particular implementation.\n\nThis is different from the standard proxy pattern, where the proxy stores a single implementation smart contract address, and calls via `delegateCall` this same implementation for every incoming function call.\n\n**Standard proxy pattern**\n\n```solidity\ncontract StandardProxy {\n\n  address public constant implementation = 0xabc...;\n\n  fallback() external payable virtual {\n    _delegateCall(implementation);\n  }\n}\n```\n\n**Router pattern**\n\n```solidity\nabstract contract Router {\n\n  fallback() external payable virtual {\n    address implementation = getImplementationForFunction(msg.sig);\n    _delegateCall(implementation);\n  }\n\n  function getImplementationForFunction(bytes4 _functionSelector) public view virtual returns (address);\n}\n```\n\nThis setup in the `Router` contract allows for different functions of the smart contract to be implemented in different logic contracts.\n\n### `Extensions` - Grouping logical functionality together\n\nBy itself, the core `Router` contract does not specify _how to store or fetch_ appropriate implementation addresses for incoming function calls.\n\nWhile the Router pattern allows to point to a different contract for each function, in practice functions are usually groupped by functionality related to a shared state (a read and a set function for example).\n\nTo make the pattern more practical, we created a generic `BaseRouter` contract that makes it easy to have logical group of functions plugged in and out of it, each group of functions being implemented in a separate implementation contract. We refer to each such implementation contract as an **_extension_**.\n\n`BaseRouter` maintains a `function_signature` → `implementation` mapping, and provides an API for updating that mapping. By updating the values stored in this map, functionality can be added to, removed from or updated in the smart contract.\n\n![updating-extensions](/docs/img/update-diagram.png)\n\n### `Extension` to `Extension` communication\n\nWhen splitting logic between multiple `Extensions` in a `Router`, one might want to access data from one `Extension` to another.\n\nA simple way to do this is by casting the current contract address as the `Extension` (ideally its interface) we're trying to call. This works from both a `Router` or any of its `Extensions`.\n\nHere's an example of accessing a IPermission `Extension` from another one:\n\n```solidity\n/// in MyExtension.sol\nmodifier onlyAdmin(address _asset) {\n  /// we access our IPermission extension by casting our own address\n  IPermissions(address(this)).hasAdminRole(msg.sender);\n}\n```\n\nNote that if we don't have a IPermission `Extension` added to our `Router`, this method will revert.\n\n### Upgrading `Extensions`\n\nJust like any upgradeable contract, there are limitations on how the data structure of the updated contract is modified. While the logic of a function can be updated safely, changing the data structure of a contract requires careful consideration.\n\nA good rule of thumb to follow is:\n\n- It is safe to append new fields to an existing data structure\n- It is _not_ safe to update the type or order of existing structs, deprecate and add new ones instead\n\nRefer to [this article](https://mirror.xyz/horsefacts.eth/EPB4o-eyDl0N8gu0gEz1uw7BTITheaZUqIAOEK1m-jE) for more information.\n\n## Feedback\n\nThe best, most open way to give feedback/suggestions for the router pattern is to open a github issue.\n\nAdditionally, since [thirdweb](https://thirdweb.com/) will be maintaining this repository, you can reach out to us at support@thirdweb.com or join our [discord](https://discord.gg/thirdweb).\n\n## Authors\n\n- [thirdweb](https://github.com/thirdweb-dev)\n","scripts":{},"_npmUser":{"name":"krishang","email":"krishang@thirdweb.com"},"repository":{"url":"https://github.com/thirdweb-dev/dynamic-contracts.git","type":"git"},"description":"Architectural pattern for writing dynamic smart contracts in Solidity","directories":{},"dependencies":{},"publishConfig":{"access":"public"},"_hasShrinkwrap":false,"readmeFilename":"README.md","_npmOperationalInternal":{"tmp":"tmp/dynamic-contracts_1.1.3-1_1692371608012_0.7336024280672124","host":"s3://npm-registry-packages"}},"1.1.3":{"name":"@thirdweb-dev/dynamic-contracts","version":"1.1.3","author":{"name":"thirdweb engineering","email":"eng@thirdweb.com"},"license":"MIT","_id":"@thirdweb-dev/dynamic-contracts@1.1.3","maintainers":[{"name":"furqantw","email":"furqan@thirdweb.com"},{"name":"jarrodwatts","email":"jarrodwatts16@gmail.com"},{"name":"yash90","email":"yash@thirdweb.com"},{"name":"nachoiacovino","email":"nacho.iacovino@gmail.com"},{"name":"adam-maj","email":"mr.adam.maj@gmail.com"},{"name":"krishang","email":"krishang@thirdweb.com"},{"name":"abenftlabs","email":"abe@nftlabs.co"},{"name":"jakeloo","email":"jake@nftlabs.co"},{"name":"joaquim-verges","email":"joaquim@thirdweb.com"},{"name":"jnsdls","email":"jonas@thirdweb.com"}],"homepage":"https://thirdweb.com/","bugs":{"url":"https://github.com/thirdweb-dev/dynamic-contracts/issues"},"dist":{"shasum":"74d12b2d3e83685cecfeb8af08252d98b66f148d","tarball":"https://registry.npmjs.org/@thirdweb-dev/dynamic-contracts/-/dynamic-contracts-1.1.3.tgz","fileCount":161,"integrity":"sha512-lQjFYsPUrdCvbkiOMPdmNlY+h6W/3Our1ukcnVClMisd4yP+G/uFCXQOSzbFVLtxrPD8cUppI/sqW6KWqvmVnw==","signatures":[{"sig":"MEUCIAvMJC5MSj2TYW/mD6QJPEBLWy6VGBivYpjfHDPW02DaAiEA/Jx6MLguCCsbNUgvD3rNSZQF6iwuYyMG5ieckC83z7c=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":24966297},"main":"index.js","scripts":{},"_npmUser":{"name":"krishang","email":"krishang@thirdweb.com"},"repository":{"url":"https://github.com/thirdweb-dev/dynamic-contracts.git","type":"git"},"description":"Architectural pattern for writing dynamic smart contracts in Solidity","directories":{},"dependencies":{},"publishConfig":{"access":"public"},"_hasShrinkwrap":false,"_npmOperationalInternal":{"tmp":"tmp/dynamic-contracts_1.1.3_1692372820194_0.9699042197874661","host":"s3://npm-registry-packages"}},"1.1.4-0":{"name":"@thirdweb-dev/dynamic-contracts","version":"1.1.4-0","author":{"name":"thirdweb engineering","email":"eng@thirdweb.com"},"license":"MIT","_id":"@thirdweb-dev/dynamic-contracts@1.1.4-0","maintainers":[{"name":"furqantw","email":"furqan@thirdweb.com"},{"name":"jarrodwatts","email":"jarrodwatts16@gmail.com"},{"name":"yash90","email":"yash@thirdweb.com"},{"name":"nachoiacovino","email":"nacho.iacovino@gmail.com"},{"name":"adam-maj","email":"mr.adam.maj@gmail.com"},{"name":"krishang","email":"krishang@thirdweb.com"},{"name":"abenftlabs","email":"abe@nftlabs.co"},{"name":"jakeloo","email":"jake@nftlabs.co"},{"name":"joaquim-verges","email":"joaquim@thirdweb.com"},{"name":"jnsdls","email":"jonas@thirdweb.com"}],"homepage":"https://thirdweb.com/","bugs":{"url":"https://github.com/thirdweb-dev/dynamic-contracts/issues"},"dist":{"shasum":"02c262487655e8e644e4d9b2e744da453f2a6173","tarball":"https://registry.npmjs.org/@thirdweb-dev/dynamic-contracts/-/dynamic-contracts-1.1.4-0.tgz","fileCount":161,"integrity":"sha512-y+MZZL7vrnExVzZEfNahEipDkoCIIzE1IH4t+OdMsvDFXXwaTLou5lOAbJQtqBM5Ny5yKbKtHs0/TODhLk7pzw==","signatures":[{"sig":"MEYCIQD8hd4oZCpeU6PihLyLWrZHiNXN9uE1wYLsyHGoqKBIpAIhAMEiQwUi+dIUBw07Vm1Rv09rl6OOYnnV9FewemQMH6PF","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":24951699},"main":"index.js","readme":"# Dynamic Contracts Standard\n\n### Architectural pattern for writing dynamic smart contracts in Solidity\n\nThis repository provides core interfaces and preset implementations that:\n\n- Provide guardrails for writing dynamic contracts that can have functionality added, updated or removed over time\n- Enables scaling up contracts by eliminating the restriction of contract size limit altogether\n\n> This architecture builds upon the diamond pattern ([EIP-2535](https://eips.ethereum.org/EIPS/eip-2535)). We've taken inspiration from it, and boiled it down to its leanest, simplest form.\n\n## Installation\n\n#### Forge\n\n```bash\nforge install https://github.com/thirdweb-dev/dynamic-contracts\n```\n\n#### Hardhat\n\n```bash\nnpm install @thirdweb-dev/dynamic-contracts\n```\n\n## Core concepts\n\n- A `Router` contract can route function calls to any number of destination contracts\n- We call these destination contracts `Extensions`.\n- `Extensions` can be added/updated/removed at any time, according to a predefined set of rules.\n\n![router-pattern](/docs/img/router-diagram.png)\n\n## Getting started\n\n### 1. `Router` - the entrypoint contract\n\nThe simplest way to write a `Router` contract is to extend the preset [`BaseRouter`](/src/presets/BaseRouter.sol) available in this repository.\n\n```solidity\nimport \"lib/dynamic-contracts/src/presets/BaseRouter.sol\";\n```\n\nThe `BaseRouter` contract comes with an API to add/update/remove extensions from the contract. It is an abstract contract, and expects its consumer to implement the `_canSetExtension(...)` function, which specifies the conditions under which `Extensions` can be added, updated or removed. The rest of the implementation is generic and usable for all purposes.\n\n```solidity\nfunction _canSetExtension(Extension memory _extension) internal view virtual returns (bool);\n```\n\nHere's a very simple example that allows only the original contract deployer to add/update/remove `Extensions`.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"lib/dynamic-contracts/src/presets/BaseRouter.sol\";\n\n/// Example usage of `BaseRouter`, for demonstration only\n\ncontract SimpleRouter is BaseRouter {\n\n    address public deployer;\n\n    constructor(Extension[] memory _extensions) BaseRouter(_extensions) {\n        deployer = msg.sender;\n    }\n\n    /// @dev Returns whether extensions can be set in the given execution context.\n    function _canSetExtension(Extension memory _extension) internal view virtual override returns (bool) {\n        return msg.sender == deployer;\n    }\n}\n```\n\n#### Choosing a permission model:\n\nThe main decision as a `Router` contract author is to decide the permission model to add/update/remove extensions. This repository offers some presets for a few possible permission models:\n\n- #### [`RouterUpgradeable`](/src/presets/example/RouterUpgradeable.sol)\n\nThis a is a preset that **allows the contract owner to add / upgrade / remove extensions**. The contract owner can be changed. This is a very basic permission model, but enough for some use cases. You can expand on this and use a permission based model instead for example.\n\n- #### [`RouterImmutable`](/src/presets/example/RouterImmutable.sol)\n\nThis is a preset you can use to **create static contracts that cannot be updated or get new functionality**. This still allows you to create modular contracts that go beyond the contract size limit, but guarantees that the original functionality cannot be altered. With this model, you would pass all the `Extensions` for this contract at construction time, and guarantee that the functionality is immutable.\n\nOther permissions models might include an explicit list of extensions that can be added or removed for example. The implementation is up to the Router author.\n\n- #### [`RouterRegistryConstrained`](/src/presets/example/RouterRegistryConstrained.sol)\n\nThis is a preset that **allows the owner to change extensions if they are defined on a given registry contract**. This is meant to demonstrate how a protocol ecosystem could constrain extensions to known, audited contracts, for instance. The registry and router upgrade models are of course too basic for production as written.\n\n### 2. `Extensions` - implementing routeable contracts\n\nAn `Extension` contract is written like any other smart contract, except that its state must be defined using a `struct` within a `library` and at a well defined storage location. This storage technique is known as [storage structs](https://mirror.xyz/horsefacts.eth/EPB4o-eyDl0N8gu0gEz1uw7BTITheaZUqIAOEK1m-jE). This is important to ensure that state defined in an `Extension` doesn't conflict with the state of another `Extension` of the same `Router` at the same storage location.\n\nHere's an example of a simple contract written as an `Extension` contract:\n\n```solidity\n\n/// library defining the data structure of our contract\nlibrary NumberStorage {\n    /// specify the storage location, needs to be unique\n    bytes32 public constant NUMBER_STORAGE_POSITION = keccak256(\"number.storage\");\n\n    /// the state data struct\n    struct Data {\n        uint256 number;\n    }\n\n    /// state accessor, always use this to access the state data\n    function numberStorage() internal pure returns (Data storage numberData) {\n        bytes32 position = NUMBER_STORAGE_POSITION;\n        assembly {\n            numberData.slot := position\n        }\n    }\n}\n\n/// implementation of our contract's logic, notice the lack of local state\n/// state is always accessed via the storage library defined above\ncontract Number {\n\n    function setNumber(uint256 _newNumber) external {\n        NumberStorage.Data storage data = NumberStorage.numberStorage();\n        data.number = _newNumber;\n    }\n\n    function getNumber() external view returns (uint256) {\n        NumberStorage.Data storage data = NumberStorage.numberStorage();\n        return data.number;\n    }\n}\n```\n\nTo compare, here is the same contract written in a regular way:\n\n```solidity\ncontract Number {\n\n    uint256 private number;\n\n    function setNumber(uint256 _newNumber) external {\n        number = _newNumber;\n    }\n\n    function getNumber() external view returns (uint256) {\n        return number;\n    }\n}\n```\n\nThe main difference is how the state is defined. While an `Extension` written this way requires a bit more boilerplate to setup, it is a one time cost that ensures full modularity when using multiple `Extension` contracts with a single `Router`.\n\n### 3. Deploying a `Router`\n\nDeploying a contract in the router pattern looks a little different from deploying a regular contract.\n\n1. Deploy all your `Extension` contracts first. You only need to do this once per `Extension`. Deployed `Extensions` can be re-used by many different `Router` contracts.\n\n2. Deploy your `Router` contract that implements `BaseRouter`.\n\n3. Optionally, you pass your default `Extensions` in the constructor of your `BaseRouter` at deploy time. This is a convenient way to bootstrap an `Router` with a set of default `Extension` in one transaction.\n\n### 4. Adding, removing or upgrading `Extensions` post deployment\n\nThe preset `BaseRouter` comes with an API to add/update/remove `Extensions` at any time after deployment:\n\n- `addExtension()`: function to add completely new `Extension` to your `Router`.\n- `updateExtension()`: function to update the address, metadata, or functions of an existing `Extension` in your `Router`.\n- `removeExtension()`: remove an existing `Extension` from your `Router`.\n\nThe permission to modify `Extensions` is encoded in your `Router` and can have different conditions.\n\nWith this pattern, your contract is now dynamically updeatable, with granular control.\n\n- Add entire new functionality to your contract post deployment\n- Remove functionality when it's not longer needed\n- Deploy security and bug fixes for a single function of your contract\n\n---\n\n## Going deeper - background and technical details\n\nIn the standard proxy pattern for smart contracts, a proxy smart contract calls a _logic contract_ using `delegateCall`. This allows proxies to keep a persistent state (storage and balance) while the code is delegated to the logic contract. ([EIP-1967](https://eips.ethereum.org/EIPS/eip-1967))\n\nThe pattern aims to solve for the following two limitations of this standard proxy pattern:\n\n1. The proxy contract points to a single smart contract as its _logic contract_, at a time.\n2. The _logic contract_ is subject to the smart contract size limit of ~24kb ([EIP-170](https://eips.ethereum.org/EIPS/eip-170)). This prevents a single smart contract from having all of the features one may want it to have.\n\n> **Note:** The diamond pattern ([EIP-2535](https://eips.ethereum.org/EIPS/eip-2535)) anticipates these same problems and more. We've taken inspiration from it, and boiled it down to its leanest, simplest form.\n\nThe router pattern eliminates these limitations performing a lookup for the implementation smart contract address associated with every incoming function call, and make a `delegateCall` to that particular implementation.\n\nThis is different from the standard proxy pattern, where the proxy stores a single implementation smart contract address, and calls via `delegateCall` this same implementation for every incoming function call.\n\n**Standard proxy pattern**\n\n```solidity\ncontract StandardProxy {\n\n  address public constant implementation = 0xabc...;\n\n  fallback() external payable virtual {\n    _delegateCall(implementation);\n  }\n}\n```\n\n**Router pattern**\n\n```solidity\nabstract contract Router {\n\n  fallback() external payable virtual {\n    address implementation = getImplementationForFunction(msg.sig);\n    _delegateCall(implementation);\n  }\n\n  function getImplementationForFunction(bytes4 _functionSelector) public view virtual returns (address);\n}\n```\n\nThis setup in the `Router` contract allows for different functions of the smart contract to be implemented in different logic contracts.\n\n### `Extensions` - Grouping logical functionality together\n\nBy itself, the core `Router` contract does not specify _how to store or fetch_ appropriate implementation addresses for incoming function calls.\n\nWhile the Router pattern allows to point to a different contract for each function, in practice functions are usually groupped by functionality related to a shared state (a read and a set function for example).\n\nTo make the pattern more practical, we created a generic `BaseRouter` contract that makes it easy to have logical group of functions plugged in and out of it, each group of functions being implemented in a separate implementation contract. We refer to each such implementation contract as an **_extension_**.\n\n`BaseRouter` maintains a `function_signature` → `implementation` mapping, and provides an API for updating that mapping. By updating the values stored in this map, functionality can be added to, removed from or updated in the smart contract.\n\n![updating-extensions](/docs/img/update-diagram.png)\n\n### `Extension` to `Extension` communication\n\nWhen splitting logic between multiple `Extensions` in a `Router`, one might want to access data from one `Extension` to another.\n\nA simple way to do this is by casting the current contract address as the `Extension` (ideally its interface) we're trying to call. This works from both a `Router` or any of its `Extensions`.\n\nHere's an example of accessing a IPermission `Extension` from another one:\n\n```solidity\n/// in MyExtension.sol\nmodifier onlyAdmin(address _asset) {\n  /// we access our IPermission extension by casting our own address\n  IPermissions(address(this)).hasAdminRole(msg.sender);\n}\n```\n\nNote that if we don't have a IPermission `Extension` added to our `Router`, this method will revert.\n\n### Upgrading `Extensions`\n\nJust like any upgradeable contract, there are limitations on how the data structure of the updated contract is modified. While the logic of a function can be updated safely, changing the data structure of a contract requires careful consideration.\n\nA good rule of thumb to follow is:\n\n- It is safe to append new fields to an existing data structure\n- It is _not_ safe to update the type or order of existing structs, deprecate and add new ones instead\n\nRefer to [this article](https://mirror.xyz/horsefacts.eth/EPB4o-eyDl0N8gu0gEz1uw7BTITheaZUqIAOEK1m-jE) for more information.\n\n## Feedback\n\nThe best, most open way to give feedback/suggestions for the router pattern is to open a github issue.\n\nAdditionally, since [thirdweb](https://thirdweb.com/) will be maintaining this repository, you can reach out to us at support@thirdweb.com or join our [discord](https://discord.gg/thirdweb).\n\n## Authors\n\n- [thirdweb](https://github.com/thirdweb-dev)\n","scripts":{},"_npmUser":{"name":"krishang","email":"krishang@thirdweb.com"},"repository":{"url":"https://github.com/thirdweb-dev/dynamic-contracts.git","type":"git"},"description":"Architectural pattern for writing dynamic smart contracts in Solidity","directories":{},"dependencies":{},"publishConfig":{"access":"public"},"_hasShrinkwrap":false,"readmeFilename":"README.md","_npmOperationalInternal":{"tmp":"tmp/dynamic-contracts_1.1.4-0_1692390996248_0.6618934201777014","host":"s3://npm-registry-packages"}},"1.1.4":{"name":"@thirdweb-dev/dynamic-contracts","version":"1.1.4","author":{"name":"thirdweb engineering","email":"eng@thirdweb.com"},"license":"MIT","_id":"@thirdweb-dev/dynamic-contracts@1.1.4","maintainers":[{"name":"furqantw","email":"furqan@thirdweb.com"},{"name":"jarrodwatts","email":"jarrodwatts16@gmail.com"},{"name":"yash90","email":"yash@thirdweb.com"},{"name":"nachoiacovino","email":"nacho.iacovino@gmail.com"},{"name":"adam-maj","email":"mr.adam.maj@gmail.com"},{"name":"krishang","email":"krishang@thirdweb.com"},{"name":"abenftlabs","email":"abe@nftlabs.co"},{"name":"jakeloo","email":"jake@nftlabs.co"},{"name":"joaquim-verges","email":"joaquim@thirdweb.com"},{"name":"jnsdls","email":"jonas@thirdweb.com"}],"homepage":"https://thirdweb.com/","bugs":{"url":"https://github.com/thirdweb-dev/dynamic-contracts/issues"},"dist":{"shasum":"f14de117bad647d0f32073325627f4b31963446f","tarball":"https://registry.npmjs.org/@thirdweb-dev/dynamic-contracts/-/dynamic-contracts-1.1.4.tgz","fileCount":161,"integrity":"sha512-uvZBvcbrJH9IzGkQgaJGsKrRgKh3PcRtrbegk62aGEmv1+vlNakcbaVlOiNC8jHpc/S2pZ29CmuKZntl1cEF8Q==","signatures":[{"sig":"MEQCICHc5HnWfVExgBC1yOkf2LIy6YaxLC3GIB+L3zivqNZWAiB23YSogGe/NjZ//r+/b8jtP08K55hFvg818MduQ+gZ1A==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":24951697},"main":"index.js","scripts":{},"_npmUser":{"name":"krishang","email":"krishang@thirdweb.com"},"repository":{"url":"https://github.com/thirdweb-dev/dynamic-contracts.git","type":"git"},"description":"Architectural pattern for writing dynamic smart contracts in Solidity","directories":{},"dependencies":{},"publishConfig":{"access":"public"},"_hasShrinkwrap":false,"_npmOperationalInternal":{"tmp":"tmp/dynamic-contracts_1.1.4_1692391451274_0.5543330960080237","host":"s3://npm-registry-packages"}},"1.2.0-0":{"name":"@thirdweb-dev/dynamic-contracts","version":"1.2.0-0","author":{"name":"thirdweb engineering","email":"eng@thirdweb.com"},"license":"MIT","_id":"@thirdweb-dev/dynamic-contracts@1.2.0-0","maintainers":[{"name":"furqantw","email":"furqan@thirdweb.com"},{"name":"jarrodwatts","email":"jarrodwatts16@gmail.com"},{"name":"yash90","email":"yash@thirdweb.com"},{"name":"nachoiacovino","email":"nacho.iacovino@gmail.com"},{"name":"adam-maj","email":"mr.adam.maj@gmail.com"},{"name":"krishang","email":"krishang@thirdweb.com"},{"name":"abenftlabs","email":"abe@nftlabs.co"},{"name":"jakeloo","email":"jake@nftlabs.co"},{"name":"joaquim-verges","email":"joaquim@thirdweb.com"},{"name":"jnsdls","email":"jonas@thirdweb.com"}],"homepage":"https://thirdweb.com/","bugs":{"url":"https://github.com/thirdweb-dev/dynamic-contracts/issues"},"dist":{"shasum":"6bb7e009292d6994f514a1e1b8c420c4325758fa","tarball":"https://registry.npmjs.org/@thirdweb-dev/dynamic-contracts/-/dynamic-contracts-1.2.0-0.tgz","fileCount":183,"integrity":"sha512-l4lzR5Mi/G4aZcxCiXDQbOHKeeKl9eeh1d8oYgT/DSg82TdSNXvzMty7oXPF7b95o4F8sGBIhqNJsoFUAujEbw==","signatures":[{"sig":"MEUCIQCs7m1aSdoUHzvyzHMm6T8icutapnpTFq0wd8PdgD7pYQIgO4b/v52aiEyoay8A4KilhjbOR6jYUqbphXRev2KAkDw=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":46474878},"main":"index.js","readme":"# ERC-7504: Dynamic Contracts standard.\n\n**Architectural pattern for writing client-friendly one-to-many proxy contracts (aka 'dynamic contracts') in Solidity.**\n\nThis repository implements ERC-7504: Dynamic Contracts [[DRAFT](https://ethereum-magicians.org/t/erc-7504-dynamic-contracts/15551)]. This repository provides core interfaces and preset implementations that:\n\n- Provide guardrails for writing dynamic contracts that can have functionality added, updated or removed over time.\n- Enables scaling up contracts by eliminating the restriction of contract size limit altogether.\n\n> ⚠️ **ERC-7504** [DRAFT] is now published and open for feedback! You can read the EIP and provide your feedback at its [ethereum-magicians discussion link](https://ethereum-magicians.org/t/erc-7504-dynamic-contracts/15551).\n\n# Installation\n\n### Forge projects:\n\n```bash\nforge install https://github.com/thirdweb-dev/dynamic-contracts\n```\n\n### Hardhat / JS based projects:\n\n```bash\nnpm install @thirdweb-dev/dynamic-contracts\n```\n\n### Project structure\n\n```shell\nsrc\n|\n|-- core\n|   |- Router: \"Minmal abstract contract implementation of EIP-7504 Router.\"\n|   |- RouterPayable: \"A Router with `receive` as a fixed function.\"\n|\n|-- presets\n|   |-- ExtensionManager: \"Defined storage layout and API for managing a router's extensions.\"\n|   |-- DefaultExtensionSet: \"A static store of a set of extensions, initialized on deployment.\"\n|   |-- BaseRouter: \"A Router with an ExtensionManager.\"\n|   |-- BaseRouterWithDefaults: \"A BaseRouter initialized with extensions on deployment.\"\n|\n|-- interface: \"Interfaces for core and preset contracts.\"\n|-- example: \"Example dynamic contracts built with presets.\"\n|-- lib: \"Storage layouts and helper libraries.\"\n```\n\n# Running locally\n\nThis repository is a forge project. ([forge handbook](https://book.getfoundry.sh/))\n\n**Clone the repository:**\n\n```bash\ngit clone https://github.com/thirdweb-dev/dynamic-contracts.git\n```\n\n**Install dependencies:**\n\n```bash\nforge install\n```\n\n**Compile contracts:**\n\n```bash\nforge build\n```\n\n**Run tests:**\n\n```bash\nforge test\n```\n\n**Generate documentation**\n\n```bash\nforge doc --serve --port 4000\n```\n\n# Core concepts\n\nAn “upgradeable smart contract” is actually two kinds of smart contracts considered together as one system:\n\n1. **Proxy** smart contract: The smart contract whose state/storage we’re concerned with.\n2. **Implementation** smart contract: A stateless smart contract that defines the logic for how the proxy smart contract’s state can be mutated.\n\n![A proxy contract that forwards all calls to a single implementation contract](https://ipfs.io/ipfs/QmdzTiw5YuaMa1rjBtoyDuGHHRLdi9Afmh2Tu9Rjj1XuoA/proxy-with-single-impl.png)\n\nThe job of a proxy contract is to forward any calls it receives to the implementation contract via `delegateCall`. As a shorthand — a proxy contract stores state, and always asks an implementation contract how to mutate its state (upon receiving a call).\n\nERC-7504 introduces a `Router` smart contract.\n\n![A router contract that forwards calls to one of many implementation contracts based on the incoming calldata](https://ipfs.io/ipfs/Qmasd6DHrqMnkhifoapWAeWSs8eEJoFbzKJUpeEBacPAM7/router-many-impls.png)\n\nInstead of always delegateCall-ing the same implementation contract, a `Router` delegateCalls a particular implementation contract (i.e. “Extension”) for the particular function call it receives.\n\nA router stores a map from function selectors → to the implementation contract where the given function is implemented. “Upgrading a contract” now simply means updating what implementation contract a given function, or functions are mapped to.\n\n![Upgrading a contract means updating what implementation a given function, or functions are mapped to](https://ipfs.io/ipfs/QmUWk4VrFsAQ8gSMvTKwPXptJiMjZdihzUNhRXky7VmgGz/router-upgrades.png)\n\n# Getting started\n\nThe simplest way to write a `Router` contract is to extend the preset [`BaseRouter`](/src/presets/BaseRouter.sol) available in this repository.\n\n```solidity\nimport \"lib/dynamic-contracts/src/presets/BaseRouter.sol\";\n```\n\nThe `BaseRouter` contract comes with an API to add/replace/remove extensions from the contract. It is an abstract contract, and expects its consumer to implement the `_isAuthorizedCallToUpgrade` function, which specifies the conditions under which `Extensions` can be added, replaced or removed. The rest of the implementation is generic and usable for all purposes.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@thirdweb-dev/dynamic-contracts/src/presets/BaseRouter.sol\";\n\n/// Example usage of `BaseRouter`, for demonstration only\n\ncontract SimpleRouter is BaseRouter {\n\n    address public deployer;\n\n    constructor() {\n        deployer = msg.sender;\n    }\n\n    /// @dev Returns whether all relevant permission checks are met before any upgrade.\n    function isAuthorizedCallToUpgrade() internal view virtual override returns (bool) {\n        return msg.sender == deployer;\n    }\n}\n```\n\n## Choosing a permission model\n\nThe main decision as a `Router` contract author is to decide the permission model to add/replace/remove extensions. This repository offers some examples of a few possible permission models:\n\n- [**RouterImmutable**](https://github.com/thirdweb-dev/dynamic-contracts/blob/main/src/example/RouterImmutable.sol)\n\n  This is a preset you can use to create static contracts that cannot be updated or get new functionality. This still allows you to create modular contracts that go beyond the contract size limit, but guarantees that the original functionality cannot be altered. With this model, you would pass all the Extensions for this contract at construction time, and guarantee that the functionality is immutable.\n\n- [**RouterUpgradeable**](https://github.com/thirdweb-dev/dynamic-contracts/blob/main/src/example/RouterUpgradeable.sol)\n\n  This a is a preset that allows the contract owner to add / replace / remove extensions. The contract owner can be changed. This is a very basic permission model, but enough for some use cases. You can expand on this and use a permission based model instead for example.\n\n- [**RouterRegistryContrained**](https://github.com/thirdweb-dev/dynamic-contracts/blob/main/src/example/RouterRegistryConstrained.sol)\n\n  This is a preset that allows the owner to change extensions if they are defined on a given registry contract. This is meant to demonstrate how a protocol ecosystem could constrain extensions to known, audited contracts, for instance. The registry and router upgrade models are of course too basic for production as written.\n\n## Writing extension smart contracts\n\nAn `Extension` contract is written like any other smart contract, except that its state must be defined using a `struct` within a `library` and at a well defined storage location. This storage technique is known as [storage structs](https://mirror.xyz/horsefacts.eth/EPB4o-eyDl0N8gu0gEz1uw7BTITheaZUqIAOEK1m-jE).\n\n**Example:** `ExtensionManagerStorage` defines the storage layout for the `ExtensionManager` contract.\n\n```solidity\n// SPDX-License-Identifier: MIT\n// @author: thirdweb (https://github.com/thirdweb-dev/dynamic-contracts)\n\npragma solidity ^0.8.0;\n\nimport \"./StringSet.sol\";\nimport \"../interface/IExtension.sol\";\n\nlibrary ExtensionManagerStorage {\n\n    /// @custom:storage-location erc7201:extension.manager.storage\n    bytes32 public constant EXTENSION_MANAGER_STORAGE_POSITION = keccak256(abi.encode(uint256(keccak256(\"extension.manager.storage\")) - 1));\n\n    struct Data {\n        /// @dev Set of names of all extensions stored.\n        StringSet.Set extensionNames;\n        /// @dev Mapping from extension name => `Extension` i.e. extension metadata and functions.\n        mapping(string => IExtension.Extension) extensions;\n        /// @dev Mapping from function selector => metadata of the extension the function belongs to.\n        mapping(bytes4 => IExtension.ExtensionMetadata) extensionMetadata;\n    }\n\n    function data() internal pure returns (Data storage data_) {\n        bytes32 position = EXTENSION_MANAGER_STORAGE_POSITION;\n        assembly {\n            data_.slot := position\n        }\n    }\n}\n```\n\nEach `Extension` of a router must occupy a unique, unused storage location. This is important to ensure that state updates defined in one `Extension` doesn't conflict with the state updates defined in another `Extension`, leading to corrupted state.\n\n## Extensions: logical grouping of functionality\n\nBy itself, the core `Router` contract does not specify _how to store or fetch_ appropriate implementation addresses for incoming function calls.\n\nWhile the Router pattern allows to point to a different contract for each function, in practice functions are usually groupped by functionality related to a shared state (a read and a set function for example).\n\nTo make the pattern more practical, we created a generic `BaseRouter` contract that makes it easy to have logical group of functions plugged in and out of it, each group of functions being implemented in a separate implementation contract. We refer to each such implementation contract as an **_extension_**.\n\n`BaseRouter` maintains a `function_signature` → `implementation` mapping, and provides an API for updating that mapping. By updating the values stored in this map, functionality can be added to, removed from or updated in the smart contract.\n\n![Upgrading a contract means updating what implementation a given function, or functions are mapped to](https://ipfs.io/ipfs/QmUWk4VrFsAQ8gSMvTKwPXptJiMjZdihzUNhRXky7VmgGz/router-upgrades.png)\n\n## Deploying a Router\n\nDeploying a contract in the router pattern looks a little different from deploying a regular contract.\n\n1. Deploy all your `Extension` contracts first. You only need to do this once per `Extension`. Deployed `Extensions` can be re-used by many different `Router` contracts.\n\n2. Deploy your `Router` contract that implements `BaseRouter`.\n3. Add extensions to youe router via the API available in `BaseRouter`. (Alternatively, you can use `BaseRouterDefaults` which can be initialized with a set of extensions on deployment.)\n\n### `Extensions` - Grouping logical functionality together\n\nBy itself, the core `Router` contract does not specify _how to store or fetch_ appropriate implementation addresses for incoming function calls.\n\nWhile the Router pattern allows to point to a different contract for each function, in practice functions are usually groupped by functionality related to a shared state (a read and a set function for example).\n\nTo make the pattern more practical, we created a generic `BaseRouter` contract that makes it easy to have logical group of functions plugged in and out of it, each group of functions being implemented in a separate implementation contract. We refer to each such implementation contract as an **_extension_**.\n\n`BaseRouter` maintains a `function_signature` → `implementation` mapping, and provides an API for updating that mapping. By updating the values stored in this map, functionality can be added to, removed from or updated in the smart contract.\n\n## Extension to Extension communication\n\nWhen splitting logic between multiple extensions in a `Router`, one might want to access data from one `Extension` to another.\n\nA simple way to do this is by casting the current contract address as the `Extension` (ideally its interface) we're trying to call. This works from both a `Router` or any of its extensions.\n\nHere's an example of accessing a `IPermission` extension from another one:\n\n```solidity\nmodifier onlyAdmin(address _asset) {\n  /// we access our IPermission extension by casting our own address\n  IPermissions(address(this)).hasAdminRole(msg.sender);\n}\n```\n\nNote that if we don't have an `IPermission` extension added to our `Router`, this method will revert.\n\n## Upgrading Extensions\n\nJust like any upgradeable contract, there are limitations on how the data structure of the updated contract is modified. While the logic of a function can be updated safely, changing the data structure of a contract requires careful consideration.\n\nA good rule of thumb to follow is:\n\n- It is safe to append new fields to an existing data structure\n- It is _not_ safe to update the type or order of existing structs; deprecate and add new ones instead.\n\nRefer to [this article](https://mirror.xyz/horsefacts.eth/EPB4o-eyDl0N8gu0gEz1uw7BTITheaZUqIAOEK1m-jE) for more information.\n\n# API reference\n\nYou can generate and view the full API reference for all contracts, interfaces and libraries in the repository by running the repository locally and running:\n\n```bash\nforge doc --serve --port 4000\n```\n\n## Router\n\n```solidity\nimport \"@thirdweb-dev/dynamic-contracts/src/core/Router.sol\";\n```\n\nThe `Router` smart contract implements the ERC-7504 [`Router` interface](https://github.com/thirdweb-dev/dynamic-contracts/blob/main/src/interface/IRouter.sol).\n\nFor any given function call made to the Router contract that reaches the fallback function, the contract performs a delegateCall on the address returned by `getImplementationForFunction(msg.sig)`.\n\nThis is an abstract contract that expects you to override and implement the following functions:\n\n- `getImplementationForFunction`\n  ```solidity\n  function getImplementationForFunction(bytes4 _functionSelector) public view virtual returns (address implementation);\n  ```\n\n### fallback\n\ndelegateCalls the appropriate implementation address for the given incoming function call.\n\n_The implementation address to delegateCall MUST be retrieved from calling `getImplementationForFunction` with the\nincoming call's function selector._\n\n```solidity\nfallback() external payable virtual;\n```\n\n#### Revert conditions:\n\n- `getImplementationForFunction(msg.sig) == address(0)`\n\n### \\_delegate\n\n_delegateCalls an `implementation` smart contract._\n\n```solidity\nfunction _delegate(address implementation) internal virtual;\n```\n\n### getImplementationForFunction\n\nReturns the implementation address to delegateCall for the given function selector.\n\n```solidity\nfunction getImplementationForFunction(bytes4 _functionSelector) public view virtual returns (address implementation);\n```\n\n**Parameters**\n\n| Name                | Type     | Description                                                  |\n| ------------------- | -------- | ------------------------------------------------------------ |\n| `_functionSelector` | `bytes4` | The function selector to get the implementation address for. |\n\n**Returns**\n\n| Name             | Type      | Description                                                                 |\n| ---------------- | --------- | --------------------------------------------------------------------------- |\n| `implementation` | `address` | The implementation address to delegateCall for the given function selector. |\n\n## ExtensionManager\n\n```solidity\nimport \"@thirdweb-dev/dynamic-contracts/src/presets/ExtensionManager.sol\";\n```\n\nThe `ExtensionManager` contract provides a defined storage layout and API for managing and fetching a router's extensions. This contract implements the ERC-7504 [`RouterState` interface](https://github.com/thirdweb-dev/dynamic-contracts/blob/main/src/interface/IRouterState.sol).\n\nThe contract's storage layout is defined in `src/lib/ExtensionManagerStorage`:\n\n```solidity\nstruct Data {\n    StringSet.Set extensionNames;\n    mapping(string => IExtension.Extension) extensions;\n    mapping(bytes4 => IExtension.ExtensionMetadata) extensionMetadata;\n}\n```\n\nThe following are some helpful **invariant properties** of `ExtensionManager`:\n\n- Each extension has a non-empty, unique name which is stored in `extensionNames`.\n- Each extension's metadata specifies a _non_-zero-address implementation.\n- A function `fn` has a non-empty metadata i.e. `extensionMetadata[fn]` value _if and only if_ it is a part of some extension `Ext` such that:\n\n  - `extensionNames` contains `Ext.metadata.name`\n  - `extensions[Ext.metadata.name].functions` includes `fn`.\n\nThis contract is meant to be used along with a Router contract, where an upgrade to the Router means updating the storage of `ExtensionManager`. For example, the preset contract `BaseRouter` inherits `Router` and `ExtensionManager` and overrides the `getImplementationForFunction` function as follows:\n\n```solidity\nfunction getImplementationForFunction(bytes4 _functionSelector) public view virtual override returns (address) {\n        return getMetadataForFunction(_functionSelector).implementation;\n    }\n```\n\nThis contract is an abstract contract that expects you to override and implement the following functions:\n\n- `isAuthorizedCallToUpgrade`\n  ```solidity\n  function isAuthorizedCallToUpgrade() internal view virtual returns (bool);\n  ```\n\n### onlyAuthorizedCall\n\nChecks that a call to any external function is authorized.\n\n```solidity\nmodifier onlyAuthorizedCall();\n```\n\n#### Revert conditions:\n\n- `!_isAuthorizedCallToUpgrade()`\n\n### getAllExtensions\n\nReturns all extensions of the Router.\n\n```solidity\nfunction getAllExtensions() external view virtual override returns (Extension[] memory allExtensions);\n```\n\n**Returns**\n\n| Name            | Type          | Description                 |\n| --------------- | ------------- | --------------------------- |\n| `allExtensions` | `Extension[]` | An array of all extensions. |\n\n### getMetadataForFunction\n\nReturns the extension metadata for a given function.\n\n```solidity\nfunction getMetadataForFunction(bytes4 functionSelector) public view virtual returns (ExtensionMetadata memory);\n```\n\n**Parameters**\n\n| Name               | Type     | Description                                              |\n| ------------------ | -------- | -------------------------------------------------------- |\n| `functionSelector` | `bytes4` | The function selector to get the extension metadata for. |\n\n**Returns**\n\n| Name     | Type                | Description                                           |\n| -------- | ------------------- | ----------------------------------------------------- |\n| `<none>` | `ExtensionMetadata` | metadata The extension metadata for a given function. |\n\n### getExtension\n\nReturns the extension metadata and functions for a given extension.\n\n```solidity\nfunction getExtension(string memory extensionName) public view virtual returns (Extension memory);\n```\n\n**Parameters**\n\n| Name            | Type     | Description                                                      |\n| --------------- | -------- | ---------------------------------------------------------------- |\n| `extensionName` | `string` | The name of the extension to get the metadata and functions for. |\n\n**Returns**\n\n| Name     | Type        | Description                                                 |\n| -------- | ----------- | ----------------------------------------------------------- |\n| `<none>` | `Extension` | The extension metadata and functions for a given extension. |\n\n### addExtension\n\nAdd a new extension to the router.\n\n```solidity\nfunction addExtension(Extension memory _extension) external onlyAuthorizedCall;\n```\n\n**Parameters**\n\n| Name         | Type        | Description           |\n| ------------ | ----------- | --------------------- |\n| `_extension` | `Extension` | The extension to add. |\n\n#### Revert conditions:\n\n- Extension name is empty.\n- Extension name is already used.\n- Extension implementation is zero address.\n- Selector and signature mismatch for some function in the extension.\n- Some function in the extension is already a part of another extension.\n\n### replaceExtension\n\nFully replace an existing extension of the router.\n\n_The extension with name `extension.name` is the extension being replaced._\n\n```solidity\nfunction replaceExtension(Extension memory _extension) external onlyAuthorizedCall;\n```\n\n**Parameters**\n\n| Name         | Type        | Description                            |\n| ------------ | ----------- | -------------------------------------- |\n| `_extension` | `Extension` | The extension to replace or overwrite. |\n\n#### Revert conditions:\n\n- Extension being replaced does not exist.\n- Provided extension's implementation is zero address.\n- Selector and signature mismatch for some function in the provided extension.\n- Some function in the provided extension is already a part of another extension.\n\n### removeExtension\n\nRemove an existing extension from the router.\n\n```solidity\nfunction removeExtension(string memory _extensionName) external onlyAuthorizedCall;\n```\n\n**Parameters**\n\n| Name             | Type     | Description                          |\n| ---------------- | -------- | ------------------------------------ |\n| `_extensionName` | `string` | The name of the extension to remove. |\n\n#### Revert conditions:\n\n- Extension being removed does not exist.\n\n### enableFunctionInExtension\n\nEnables a single function in an existing extension.\n\n_Makes the given function callable on the router._\n\n```solidity\nfunction enableFunctionInExtension(string memory _extensionName, ExtensionFunction memory _function)\n    external\n    onlyAuthorizedCall;\n```\n\n**Parameters**\n\n| Name             | Type                | Description                                               |\n| ---------------- | ------------------- | --------------------------------------------------------- |\n| `_extensionName` | `string`            | The name of the extension to which `extFunction` belongs. |\n| `_function`      | `ExtensionFunction` | The function to enable.                                   |\n\n#### Revert conditions:\n\n- Provided extension does not exist.\n- Selector and signature mismatch for some function in the provided extension.\n- Provided function is already a part of another extension.\n\n### disableFunctionInExtension\n\nDisables a single function in an Extension.\n\n```solidity\nfunction disableFunctionInExtension(string memory _extensionName, bytes4 _functionSelector)\n    external\n    onlyAuthorizedCall;\n```\n\n**Parameters**\n\n| Name                | Type     | Description                                                                    |\n| ------------------- | -------- | ------------------------------------------------------------------------------ |\n| `_extensionName`    | `string` | The name of the extension to which the function of `functionSelector` belongs. |\n| `_functionSelector` | `bytes4` | The function to disable.                                                       |\n\n#### Revert conditions:\n\n- Provided extension does not exist.\n- Provided function is not part of provided extension.\n\n### \\_getExtension\n\n_Returns the Extension for a given name._\n\n```solidity\nfunction _getExtension(string memory _extensionName) internal view returns (Extension memory);\n```\n\n### \\_setMetadataForExtension\n\n_Sets the ExtensionMetadata for a given extension._\n\n```solidity\nfunction _setMetadataForExtension(string memory _extensionName, ExtensionMetadata memory _metadata) internal;\n```\n\n### \\_deleteMetadataForExtension\n\n_Deletes the ExtensionMetadata for a given extension._\n\n```solidity\nfunction _deleteMetadataForExtension(string memory _extensionName) internal;\n```\n\n### \\_setMetadataForFunction\n\n_Sets the ExtensionMetadata for a given function._\n\n```solidity\nfunction _setMetadataForFunction(bytes4 _functionSelector, ExtensionMetadata memory _metadata) internal;\n```\n\n### \\_deleteMetadataForFunction\n\n_Deletes the ExtensionMetadata for a given function._\n\n```solidity\nfunction _deleteMetadataForFunction(bytes4 _functionSelector) internal;\n```\n\n### \\_enableFunctionInExtension\n\n_Enables a function in an Extension._\n\n```solidity\nfunction _enableFunctionInExtension(string memory _extensionName, ExtensionFunction memory _extFunction)\n    internal\n    virtual;\n```\n\n### \\_disableFunctionInExtension\n\nNote: `bytes4(0)` is the function selector for the `receive` function.\nSo, we maintain a special fn selector-signature mismatch check for the `receive` function.\n\n_Disables a given function in an Extension._\n\n```solidity\nfunction _disableFunctionInExtension(string memory _extensionName, bytes4 _functionSelector) internal;\n```\n\n### \\_removeAllFunctionsFromExtension\n\n_Removes all functions from an Extension._\n\n```solidity\nfunction _removeAllFunctionsFromExtension(string memory _extensionName) internal;\n```\n\n### \\_canAddExtension\n\n_Returns whether a new extension can be added in the given execution context._\n\n```solidity\nfunction _canAddExtension(Extension memory _extension) internal virtual returns (bool);\n```\n\n### \\_canReplaceExtension\n\n_Returns whether an extension can be replaced in the given execution context._\n\n```solidity\nfunction _canReplaceExtension(Extension memory _extension) internal virtual returns (bool);\n```\n\n### \\_canRemoveExtension\n\n_Returns whether an extension can be removed in the given execution context._\n\n```solidity\nfunction _canRemoveExtension(string memory _extensionName) internal virtual returns (bool);\n```\n\n### \\_canEnableFunctionInExtension\n\n_Returns whether a function can be enabled in an extension in the given execution context._\n\n```solidity\nfunction _canEnableFunctionInExtension(string memory _extensionName, ExtensionFunction memory)\n    internal\n    view\n    virtual\n    returns (bool);\n```\n\n### \\_canDisableFunctionInExtension\n\n_Returns whether a function can be disabled in an extension in the given execution context._\n\n```solidity\nfunction _canDisableFunctionInExtension(string memory _extensionName, bytes4 _functionSelector)\n    internal\n    view\n    virtual\n    returns (bool);\n```\n\n### \\_extensionManagerStorage\n\n_Returns the ExtensionManager storage._\n\n```solidity\nfunction _extensionManagerStorage() internal pure returns (ExtensionManagerStorage.Data storage data);\n```\n\n### isAuthorizedCallToUpgrade\n\n_To override; returns whether all relevant permission and other checks are met before any upgrade._\n\n```solidity\nfunction isAuthorizedCallToUpgrade() internal view virtual returns (bool);\n```\n\n## BaseRouter\n\n```solidity\nimport \"@thirdweb-dev/dynamic-contracts/src/presets/BaseRouter\"\n```\n\n`BaseRouter` inherits `Router` and `ExtensionManager`. It overrides the `Router.getImplementationForFunction` function to use the extensions stored in the `ExtensionManager` contract's storage system.\n\nThis contract is an abstract contract that expects you to override and implement the following functions:\n\n- `isAuthorizedCallToUpgrade`\n  ```solidity\n  function isAuthorizedCallToUpgrade() internal view virtual returns (bool);\n  ```\n\n### getImplementationForFunction\n\nReturns the implementation address to delegateCall for the given function selector.\n\n```solidity\nfunction getImplementationForFunction(bytes4 _functionSelector) public view virtual override returns (address);\n```\n\n**Parameters**\n\n| Name                | Type     | Description                                                  |\n| ------------------- | -------- | ------------------------------------------------------------ |\n| `_functionSelector` | `bytes4` | The function selector to get the implementation address for. |\n\n**Returns**\n\n| Name     | Type      | Description                                                                                |\n| -------- | --------- | ------------------------------------------------------------------------------------------ |\n| `<none>` | `address` | implementation The implementation address to delegateCall for the given function selector. |\n\n# Feedback\n\nThe best, most open way to give feedback/suggestions for the router pattern is to open a github issue, or comment in the ERC-7504 [ethereum-magicians discussion](https://ethereum-magicians.org/t/erc-7504-dynamic-contracts/15551).\n\nAdditionally, since [thirdweb](https://thirdweb.com/) will be maintaining this repository, you can reach out to us at support@thirdweb.com or join our [discord](https://discord.gg/thirdweb).\n\n# Authors\n\n- [thirdweb](https://github.com/thirdweb-dev)\n","scripts":{},"_npmUser":{"name":"krishang","email":"krishang@thirdweb.com"},"repository":{"url":"https://github.com/thirdweb-dev/dynamic-contracts.git","type":"git"},"description":"Architectural pattern for writing dynamic smart contracts in Solidity","directories":{},"dependencies":{},"publishConfig":{"access":"public"},"_hasShrinkwrap":false,"readmeFilename":"README.md","_npmOperationalInternal":{"tmp":"tmp/dynamic-contracts_1.2.0-0_1693934599714_0.6843557529232229","host":"s3://npm-registry-packages"}},"1.2.0":{"name":"@thirdweb-dev/dynamic-contracts","version":"1.2.0","author":{"name":"thirdweb engineering","email":"eng@thirdweb.com"},"license":"MIT","_id":"@thirdweb-dev/dynamic-contracts@1.2.0","maintainers":[{"name":"furqantw","email":"furqan@thirdweb.com"},{"name":"jarrodwatts","email":"jarrodwatts16@gmail.com"},{"name":"yash90","email":"yash@thirdweb.com"},{"name":"nachoiacovino","email":"nacho.iacovino@gmail.com"},{"name":"adam-maj","email":"mr.adam.maj@gmail.com"},{"name":"krishang","email":"krishang@thirdweb.com"},{"name":"abenftlabs","email":"abe@nftlabs.co"},{"name":"jakeloo","email":"jake@nftlabs.co"},{"name":"joaquim-verges","email":"joaquim@thirdweb.com"},{"name":"jnsdls","email":"jonas@thirdweb.com"}],"homepage":"https://thirdweb.com/","bugs":{"url":"https://github.com/thirdweb-dev/dynamic-contracts/issues"},"dist":{"shasum":"179a5b60e9f3215d2fd8216d8834cf22560511dd","tarball":"https://registry.npmjs.org/@thirdweb-dev/dynamic-contracts/-/dynamic-contracts-1.2.0.tgz","fileCount":183,"integrity":"sha512-pxX3PW7oLaYV6z70QKa9H/C5Wsyany5uhV01t+6DFk5+PJaFJ41ABhYQDD0X45S1Lw5iDf6xxLFnlymJGKOfag==","signatures":[{"sig":"MEYCIQDE6mk+uvOeZ87Oe3Ub0DsAptN2j7Xbwk1EZr+7mNhEawIhAPwU1KKDhQGdagrCb8tk51CEW6/ubOyOmIwynpXm+27L","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":46474876},"main":"index.js","scripts":{},"_npmUser":{"name":"krishang","email":"krishang@thirdweb.com"},"repository":{"url":"https://github.com/thirdweb-dev/dynamic-contracts.git","type":"git"},"description":"Architectural pattern for writing dynamic smart contracts in Solidity","directories":{},"dependencies":{},"publishConfig":{"access":"public"},"_hasShrinkwrap":false,"_npmOperationalInternal":{"tmp":"tmp/dynamic-contracts_1.2.0_1694184388197_0.4004327475483527","host":"s3://npm-registry-packages"}},"1.2.1-0":{"name":"@thirdweb-dev/dynamic-contracts","version":"1.2.1-0","author":{"name":"thirdweb engineering","email":"eng@thirdweb.com"},"license":"MIT","_id":"@thirdweb-dev/dynamic-contracts@1.2.1-0","maintainers":[{"name":"furqantw","email":"furqan@thirdweb.com"},{"name":"jarrodwatts","email":"jarrodwatts16@gmail.com"},{"name":"yash90","email":"yash@thirdweb.com"},{"name":"nachoiacovino","email":"nacho.iacovino@gmail.com"},{"name":"adam-maj","email":"mr.adam.maj@gmail.com"},{"name":"krishang","email":"krishang@thirdweb.com"},{"name":"abenftlabs","email":"abe@nftlabs.co"},{"name":"jakeloo","email":"jake@nftlabs.co"},{"name":"joaquim-verges","email":"joaquim@thirdweb.com"},{"name":"jnsdls","email":"jonas@thirdweb.com"}],"homepage":"https://thirdweb.com/","bugs":{"url":"https://github.com/thirdweb-dev/dynamic-contracts/issues"},"dist":{"shasum":"c314daa59bbef2ecca92ba96e3f53a26ff893399","tarball":"https://registry.npmjs.org/@thirdweb-dev/dynamic-contracts/-/dynamic-contracts-1.2.1-0.tgz","fileCount":189,"integrity":"sha512-Vc0Q3GthELuSMxn/DWq6g8ffD9X8UdHJ/mofKP/m6eE9ocqBrpm4HMaxaaU509vhHVrpbtF8OxmVgDCaoaH2JQ==","signatures":[{"sig":"MEYCIQCIWqWPmIKptJf6SCbmVq+1cMT5VIfXnoAAtgAPTr56vwIhAL23a5tD3V1dW0TzX5f1Cb1q1KYi4PrpvgrRrOiA6cqL","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":55507534},"main":"index.js","readme":"# ERC-7504: Dynamic Contracts standard.\n\n**Architectural pattern for writing client-friendly one-to-many proxy contracts (aka 'dynamic contracts') in Solidity.**\n\nThis repository implements ERC-7504: Dynamic Contracts [[DRAFT](https://ethereum-magicians.org/t/erc-7504-dynamic-contracts/15551)]. This repository provides core interfaces and preset implementations that:\n\n- Provide guardrails for writing dynamic contracts that can have functionality added, updated or removed over time.\n- Enables scaling up contracts by eliminating the restriction of contract size limit altogether.\n\n> ⚠️ **ERC-7504** [DRAFT] is now published and open for feedback! You can read the EIP and provide your feedback at its [ethereum-magicians discussion link](https://ethereum-magicians.org/t/erc-7504-dynamic-contracts/15551).\n\n# Installation\n\n### Forge projects:\n\n```bash\nforge install https://github.com/thirdweb-dev/dynamic-contracts\n```\n\n### Hardhat / JS based projects:\n\n```bash\nnpm install @thirdweb-dev/dynamic-contracts\n```\n\n### Project structure\n\n```shell\nsrc\n|\n|-- core\n|   |- Router: \"Minmal abstract contract implementation of EIP-7504 Router.\"\n|   |- RouterPayable: \"A Router with `receive` as a fixed function.\"\n|\n|-- presets\n|   |-- ExtensionManager: \"Defined storage layout and API for managing a router's extensions.\"\n|   |-- DefaultExtensionSet: \"A static store of a set of extensions, initialized on deployment.\"\n|   |-- BaseRouter: \"A Router with an ExtensionManager.\"\n|   |-- BaseRouterWithDefaults: \"A BaseRouter initialized with extensions on deployment.\"\n|\n|-- interface: \"Interfaces for core and preset contracts.\"\n|-- example: \"Example dynamic contracts built with presets.\"\n|-- lib: \"Storage layouts and helper libraries.\"\n```\n\n# Running locally\n\nThis repository is a forge project. ([forge handbook](https://book.getfoundry.sh/))\n\n**Clone the repository:**\n\n```bash\ngit clone https://github.com/thirdweb-dev/dynamic-contracts.git\n```\n\n**Install dependencies:**\n\n```bash\nforge install\n```\n\n**Compile contracts:**\n\n```bash\nforge build\n```\n\n**Run tests:**\n\n```bash\nforge test\n```\n\n**Generate documentation**\n\n```bash\nforge doc --serve --port 4000\n```\n\n# Core concepts\n\nAn “upgradeable smart contract” is actually two kinds of smart contracts considered together as one system:\n\n1. **Proxy** smart contract: The smart contract whose state/storage we’re concerned with.\n2. **Implementation** smart contract: A stateless smart contract that defines the logic for how the proxy smart contract’s state can be mutated.\n\n![A proxy contract that forwards all calls to a single implementation contract](https://ipfs.io/ipfs/QmdzTiw5YuaMa1rjBtoyDuGHHRLdi9Afmh2Tu9Rjj1XuoA/proxy-with-single-impl.png)\n\nThe job of a proxy contract is to forward any calls it receives to the implementation contract via `delegateCall`. As a shorthand — a proxy contract stores state, and always asks an implementation contract how to mutate its state (upon receiving a call).\n\nERC-7504 introduces a `Router` smart contract.\n\n![A router contract that forwards calls to one of many implementation contracts based on the incoming calldata](https://ipfs.io/ipfs/Qmasd6DHrqMnkhifoapWAeWSs8eEJoFbzKJUpeEBacPAM7/router-many-impls.png)\n\nInstead of always delegateCall-ing the same implementation contract, a `Router` delegateCalls a particular implementation contract (i.e. “Extension”) for the particular function call it receives.\n\nA router stores a map from function selectors → to the implementation contract where the given function is implemented. “Upgrading a contract” now simply means updating what implementation contract a given function, or functions are mapped to.\n\n![Upgrading a contract means updating what implementation a given function, or functions are mapped to](https://ipfs.io/ipfs/QmUWk4VrFsAQ8gSMvTKwPXptJiMjZdihzUNhRXky7VmgGz/router-upgrades.png)\n\n# Getting started\n\nThe simplest way to write a `Router` contract is to extend the preset [`BaseRouter`](/src/presets/BaseRouter.sol) available in this repository.\n\n```solidity\nimport \"lib/dynamic-contracts/src/presets/BaseRouter.sol\";\n```\n\nThe `BaseRouter` contract comes with an API to add/replace/remove extensions from the contract. It is an abstract contract, and expects its consumer to implement the `_isAuthorizedCallToUpgrade` function, which specifies the conditions under which `Extensions` can be added, replaced or removed. The rest of the implementation is generic and usable for all purposes.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@thirdweb-dev/dynamic-contracts/src/presets/BaseRouter.sol\";\n\n/// Example usage of `BaseRouter`, for demonstration only\n\ncontract SimpleRouter is BaseRouter {\n\n    address public deployer;\n\n    constructor() {\n        deployer = msg.sender;\n    }\n\n    /// @dev Returns whether all relevant permission checks are met before any upgrade.\n    function isAuthorizedCallToUpgrade() internal view virtual override returns (bool) {\n        return msg.sender == deployer;\n    }\n}\n```\n\n## Choosing a permission model\n\nThe main decision as a `Router` contract author is to decide the permission model to add/replace/remove extensions. This repository offers some examples of a few possible permission models:\n\n- [**RouterImmutable**](https://github.com/thirdweb-dev/dynamic-contracts/blob/main/src/example/RouterImmutable.sol)\n\n  This is a preset you can use to create static contracts that cannot be updated or get new functionality. This still allows you to create modular contracts that go beyond the contract size limit, but guarantees that the original functionality cannot be altered. With this model, you would pass all the Extensions for this contract at construction time, and guarantee that the functionality is immutable.\n\n- [**RouterUpgradeable**](https://github.com/thirdweb-dev/dynamic-contracts/blob/main/src/example/RouterUpgradeable.sol)\n\n  This a is a preset that allows the contract owner to add / replace / remove extensions. The contract owner can be changed. This is a very basic permission model, but enough for some use cases. You can expand on this and use a permission based model instead for example.\n\n- [**RouterRegistryContrained**](https://github.com/thirdweb-dev/dynamic-contracts/blob/main/src/example/RouterRegistryConstrained.sol)\n\n  This is a preset that allows the owner to change extensions if they are defined on a given registry contract. This is meant to demonstrate how a protocol ecosystem could constrain extensions to known, audited contracts, for instance. The registry and router upgrade models are of course too basic for production as written.\n\n## Writing extension smart contracts\n\nAn `Extension` contract is written like any other smart contract, except that its state must be defined using a `struct` within a `library` and at a well defined storage location. This storage technique is known as [storage structs](https://mirror.xyz/horsefacts.eth/EPB4o-eyDl0N8gu0gEz1uw7BTITheaZUqIAOEK1m-jE).\n\n**Example:** `ExtensionManagerStorage` defines the storage layout for the `ExtensionManager` contract.\n\n```solidity\n// SPDX-License-Identifier: MIT\n// @author: thirdweb (https://github.com/thirdweb-dev/dynamic-contracts)\n\npragma solidity ^0.8.0;\n\nimport \"./StringSet.sol\";\nimport \"../interface/IExtension.sol\";\n\nlibrary ExtensionManagerStorage {\n\n    /// @custom:storage-location erc7201:extension.manager.storage\n    bytes32 public constant EXTENSION_MANAGER_STORAGE_POSITION = keccak256(abi.encode(uint256(keccak256(\"extension.manager.storage\")) - 1));\n\n    struct Data {\n        /// @dev Set of names of all extensions stored.\n        StringSet.Set extensionNames;\n        /// @dev Mapping from extension name => `Extension` i.e. extension metadata and functions.\n        mapping(string => IExtension.Extension) extensions;\n        /// @dev Mapping from function selector => metadata of the extension the function belongs to.\n        mapping(bytes4 => IExtension.ExtensionMetadata) extensionMetadata;\n    }\n\n    function data() internal pure returns (Data storage data_) {\n        bytes32 position = EXTENSION_MANAGER_STORAGE_POSITION;\n        assembly {\n            data_.slot := position\n        }\n    }\n}\n```\n\nEach `Extension` of a router must occupy a unique, unused storage location. This is important to ensure that state updates defined in one `Extension` doesn't conflict with the state updates defined in another `Extension`, leading to corrupted state.\n\n## Extensions: logical grouping of functionality\n\nBy itself, the core `Router` contract does not specify _how to store or fetch_ appropriate implementation addresses for incoming function calls.\n\nWhile the Router pattern allows to point to a different contract for each function, in practice functions are usually groupped by functionality related to a shared state (a read and a set function for example).\n\nTo make the pattern more practical, we created a generic `BaseRouter` contract that makes it easy to have logical group of functions plugged in and out of it, each group of functions being implemented in a separate implementation contract. We refer to each such implementation contract as an **_extension_**.\n\n`BaseRouter` maintains a `function_signature` → `implementation` mapping, and provides an API for updating that mapping. By updating the values stored in this map, functionality can be added to, removed from or updated in the smart contract.\n\n![Upgrading a contract means updating what implementation a given function, or functions are mapped to](https://ipfs.io/ipfs/QmUWk4VrFsAQ8gSMvTKwPXptJiMjZdihzUNhRXky7VmgGz/router-upgrades.png)\n\n## Deploying a Router\n\nDeploying a contract in the router pattern looks a little different from deploying a regular contract.\n\n1. Deploy all your `Extension` contracts first. You only need to do this once per `Extension`. Deployed `Extensions` can be re-used by many different `Router` contracts.\n\n2. Deploy your `Router` contract that implements `BaseRouter`.\n3. Add extensions to youe router via the API available in `BaseRouter`. (Alternatively, you can use `BaseRouterDefaults` which can be initialized with a set of extensions on deployment.)\n\n### `Extensions` - Grouping logical functionality together\n\nBy itself, the core `Router` contract does not specify _how to store or fetch_ appropriate implementation addresses for incoming function calls.\n\nWhile the Router pattern allows to point to a different contract for each function, in practice functions are usually groupped by functionality related to a shared state (a read and a set function for example).\n\nTo make the pattern more practical, we created a generic `BaseRouter` contract that makes it easy to have logical group of functions plugged in and out of it, each group of functions being implemented in a separate implementation contract. We refer to each such implementation contract as an **_extension_**.\n\n`BaseRouter` maintains a `function_signature` → `implementation` mapping, and provides an API for updating that mapping. By updating the values stored in this map, functionality can be added to, removed from or updated in the smart contract.\n\n## Extension to Extension communication\n\nWhen splitting logic between multiple extensions in a `Router`, one might want to access data from one `Extension` to another.\n\nA simple way to do this is by casting the current contract address as the `Extension` (ideally its interface) we're trying to call. This works from both a `Router` or any of its extensions.\n\nHere's an example of accessing a `IPermission` extension from another one:\n\n```solidity\nmodifier onlyAdmin(address _asset) {\n  /// we access our IPermission extension by casting our own address\n  IPermissions(address(this)).hasAdminRole(msg.sender);\n}\n```\n\nNote that if we don't have an `IPermission` extension added to our `Router`, this method will revert.\n\n## Upgrading Extensions\n\nJust like any upgradeable contract, there are limitations on how the data structure of the updated contract is modified. While the logic of a function can be updated safely, changing the data structure of a contract requires careful consideration.\n\nA good rule of thumb to follow is:\n\n- It is safe to append new fields to an existing data structure\n- It is _not_ safe to update the type or order of existing structs; deprecate and add new ones instead.\n\nRefer to [this article](https://mirror.xyz/horsefacts.eth/EPB4o-eyDl0N8gu0gEz1uw7BTITheaZUqIAOEK1m-jE) for more information.\n\n# API reference\n\nYou can generate and view the full API reference for all contracts, interfaces and libraries in the repository by running the repository locally and running:\n\n```bash\nforge doc --serve --port 4000\n```\n\n## Router\n\n```solidity\nimport \"@thirdweb-dev/dynamic-contracts/src/core/Router.sol\";\n```\n\nThe `Router` smart contract implements the ERC-7504 [`Router` interface](https://github.com/thirdweb-dev/dynamic-contracts/blob/main/src/interface/IRouter.sol).\n\nFor any given function call made to the Router contract that reaches the fallback function, the contract performs a delegateCall on the address returned by `getImplementationForFunction(msg.sig)`.\n\nThis is an abstract contract that expects you to override and implement the following functions:\n\n- `getImplementationForFunction`\n  ```solidity\n  function getImplementationForFunction(bytes4 _functionSelector) public view virtual returns (address implementation);\n  ```\n\n### fallback\n\ndelegateCalls the appropriate implementation address for the given incoming function call.\n\n_The implementation address to delegateCall MUST be retrieved from calling `getImplementationForFunction` with the\nincoming call's function selector._\n\n```solidity\nfallback() external payable virtual;\n```\n\n#### Revert conditions:\n\n- `getImplementationForFunction(msg.sig) == address(0)`\n\n### \\_delegate\n\n_delegateCalls an `implementation` smart contract._\n\n```solidity\nfunction _delegate(address implementation) internal virtual;\n```\n\n### getImplementationForFunction\n\nReturns the implementation address to delegateCall for the given function selector.\n\n```solidity\nfunction getImplementationForFunction(bytes4 _functionSelector) public view virtual returns (address implementation);\n```\n\n**Parameters**\n\n| Name                | Type     | Description                                                  |\n| ------------------- | -------- | ------------------------------------------------------------ |\n| `_functionSelector` | `bytes4` | The function selector to get the implementation address for. |\n\n**Returns**\n\n| Name             | Type      | Description                                                                 |\n| ---------------- | --------- | --------------------------------------------------------------------------- |\n| `implementation` | `address` | The implementation address to delegateCall for the given function selector. |\n\n## ExtensionManager\n\n```solidity\nimport \"@thirdweb-dev/dynamic-contracts/src/presets/ExtensionManager.sol\";\n```\n\nThe `ExtensionManager` contract provides a defined storage layout and API for managing and fetching a router's extensions. This contract implements the ERC-7504 [`RouterState` interface](https://github.com/thirdweb-dev/dynamic-contracts/blob/main/src/interface/IRouterState.sol).\n\nThe contract's storage layout is defined in `src/lib/ExtensionManagerStorage`:\n\n```solidity\nstruct Data {\n    StringSet.Set extensionNames;\n    mapping(string => IExtension.Extension) extensions;\n    mapping(bytes4 => IExtension.ExtensionMetadata) extensionMetadata;\n}\n```\n\nThe following are some helpful **invariant properties** of `ExtensionManager`:\n\n- Each extension has a non-empty, unique name which is stored in `extensionNames`.\n- Each extension's metadata specifies a _non_-zero-address implementation.\n- A function `fn` has a non-empty metadata i.e. `extensionMetadata[fn]` value _if and only if_ it is a part of some extension `Ext` such that:\n\n  - `extensionNames` contains `Ext.metadata.name`\n  - `extensions[Ext.metadata.name].functions` includes `fn`.\n\nThis contract is meant to be used along with a Router contract, where an upgrade to the Router means updating the storage of `ExtensionManager`. For example, the preset contract `BaseRouter` inherits `Router` and `ExtensionManager` and overrides the `getImplementationForFunction` function as follows:\n\n```solidity\nfunction getImplementationForFunction(bytes4 _functionSelector) public view virtual override returns (address) {\n        return getMetadataForFunction(_functionSelector).implementation;\n    }\n```\n\nThis contract is an abstract contract that expects you to override and implement the following functions:\n\n- `isAuthorizedCallToUpgrade`\n  ```solidity\n  function isAuthorizedCallToUpgrade() internal view virtual returns (bool);\n  ```\n\n### onlyAuthorizedCall\n\nChecks that a call to any external function is authorized.\n\n```solidity\nmodifier onlyAuthorizedCall();\n```\n\n#### Revert conditions:\n\n- `!_isAuthorizedCallToUpgrade()`\n\n### getAllExtensions\n\nReturns all extensions of the Router.\n\n```solidity\nfunction getAllExtensions() external view virtual override returns (Extension[] memory allExtensions);\n```\n\n**Returns**\n\n| Name            | Type          | Description                 |\n| --------------- | ------------- | --------------------------- |\n| `allExtensions` | `Extension[]` | An array of all extensions. |\n\n### getMetadataForFunction\n\nReturns the extension metadata for a given function.\n\n```solidity\nfunction getMetadataForFunction(bytes4 functionSelector) public view virtual returns (ExtensionMetadata memory);\n```\n\n**Parameters**\n\n| Name               | Type     | Description                                              |\n| ------------------ | -------- | -------------------------------------------------------- |\n| `functionSelector` | `bytes4` | The function selector to get the extension metadata for. |\n\n**Returns**\n\n| Name     | Type                | Description                                           |\n| -------- | ------------------- | ----------------------------------------------------- |\n| `<none>` | `ExtensionMetadata` | metadata The extension metadata for a given function. |\n\n### getExtension\n\nReturns the extension metadata and functions for a given extension.\n\n```solidity\nfunction getExtension(string memory extensionName) public view virtual returns (Extension memory);\n```\n\n**Parameters**\n\n| Name            | Type     | Description                                                      |\n| --------------- | -------- | ---------------------------------------------------------------- |\n| `extensionName` | `string` | The name of the extension to get the metadata and functions for. |\n\n**Returns**\n\n| Name     | Type        | Description                                                 |\n| -------- | ----------- | ----------------------------------------------------------- |\n| `<none>` | `Extension` | The extension metadata and functions for a given extension. |\n\n### addExtension\n\nAdd a new extension to the router.\n\n```solidity\nfunction addExtension(Extension memory _extension) external onlyAuthorizedCall;\n```\n\n**Parameters**\n\n| Name         | Type        | Description           |\n| ------------ | ----------- | --------------------- |\n| `_extension` | `Extension` | The extension to add. |\n\n#### Revert conditions:\n\n- Extension name is empty.\n- Extension name is already used.\n- Extension implementation is zero address.\n- Selector and signature mismatch for some function in the extension.\n- Some function in the extension is already a part of another extension.\n\n### replaceExtension\n\nFully replace an existing extension of the router.\n\n_The extension with name `extension.name` is the extension being replaced._\n\n```solidity\nfunction replaceExtension(Extension memory _extension) external onlyAuthorizedCall;\n```\n\n**Parameters**\n\n| Name         | Type        | Description                            |\n| ------------ | ----------- | -------------------------------------- |\n| `_extension` | `Extension` | The extension to replace or overwrite. |\n\n#### Revert conditions:\n\n- Extension being replaced does not exist.\n- Provided extension's implementation is zero address.\n- Selector and signature mismatch for some function in the provided extension.\n- Some function in the provided extension is already a part of another extension.\n\n### removeExtension\n\nRemove an existing extension from the router.\n\n```solidity\nfunction removeExtension(string memory _extensionName) external onlyAuthorizedCall;\n```\n\n**Parameters**\n\n| Name             | Type     | Description                          |\n| ---------------- | -------- | ------------------------------------ |\n| `_extensionName` | `string` | The name of the extension to remove. |\n\n#### Revert conditions:\n\n- Extension being removed does not exist.\n\n### enableFunctionInExtension\n\nEnables a single function in an existing extension.\n\n_Makes the given function callable on the router._\n\n```solidity\nfunction enableFunctionInExtension(string memory _extensionName, ExtensionFunction memory _function)\n    external\n    onlyAuthorizedCall;\n```\n\n**Parameters**\n\n| Name             | Type                | Description                                               |\n| ---------------- | ------------------- | --------------------------------------------------------- |\n| `_extensionName` | `string`            | The name of the extension to which `extFunction` belongs. |\n| `_function`      | `ExtensionFunction` | The function to enable.                                   |\n\n#### Revert conditions:\n\n- Provided extension does not exist.\n- Selector and signature mismatch for some function in the provided extension.\n- Provided function is already a part of another extension.\n\n### disableFunctionInExtension\n\nDisables a single function in an Extension.\n\n```solidity\nfunction disableFunctionInExtension(string memory _extensionName, bytes4 _functionSelector)\n    external\n    onlyAuthorizedCall;\n```\n\n**Parameters**\n\n| Name                | Type     | Description                                                                    |\n| ------------------- | -------- | ------------------------------------------------------------------------------ |\n| `_extensionName`    | `string` | The name of the extension to which the function of `functionSelector` belongs. |\n| `_functionSelector` | `bytes4` | The function to disable.                                                       |\n\n#### Revert conditions:\n\n- Provided extension does not exist.\n- Provided function is not part of provided extension.\n\n### \\_getExtension\n\n_Returns the Extension for a given name._\n\n```solidity\nfunction _getExtension(string memory _extensionName) internal view returns (Extension memory);\n```\n\n### \\_setMetadataForExtension\n\n_Sets the ExtensionMetadata for a given extension._\n\n```solidity\nfunction _setMetadataForExtension(string memory _extensionName, ExtensionMetadata memory _metadata) internal;\n```\n\n### \\_deleteMetadataForExtension\n\n_Deletes the ExtensionMetadata for a given extension._\n\n```solidity\nfunction _deleteMetadataForExtension(string memory _extensionName) internal;\n```\n\n### \\_setMetadataForFunction\n\n_Sets the ExtensionMetadata for a given function._\n\n```solidity\nfunction _setMetadataForFunction(bytes4 _functionSelector, ExtensionMetadata memory _metadata) internal;\n```\n\n### \\_deleteMetadataForFunction\n\n_Deletes the ExtensionMetadata for a given function._\n\n```solidity\nfunction _deleteMetadataForFunction(bytes4 _functionSelector) internal;\n```\n\n### \\_enableFunctionInExtension\n\n_Enables a function in an Extension._\n\n```solidity\nfunction _enableFunctionInExtension(string memory _extensionName, ExtensionFunction memory _extFunction)\n    internal\n    virtual;\n```\n\n### \\_disableFunctionInExtension\n\nNote: `bytes4(0)` is the function selector for the `receive` function.\nSo, we maintain a special fn selector-signature mismatch check for the `receive` function.\n\n_Disables a given function in an Extension._\n\n```solidity\nfunction _disableFunctionInExtension(string memory _extensionName, bytes4 _functionSelector) internal;\n```\n\n### \\_removeAllFunctionsFromExtension\n\n_Removes all functions from an Extension._\n\n```solidity\nfunction _removeAllFunctionsFromExtension(string memory _extensionName) internal;\n```\n\n### \\_canAddExtension\n\n_Returns whether a new extension can be added in the given execution context._\n\n```solidity\nfunction _canAddExtension(Extension memory _extension) internal virtual returns (bool);\n```\n\n### \\_canReplaceExtension\n\n_Returns whether an extension can be replaced in the given execution context._\n\n```solidity\nfunction _canReplaceExtension(Extension memory _extension) internal virtual returns (bool);\n```\n\n### \\_canRemoveExtension\n\n_Returns whether an extension can be removed in the given execution context._\n\n```solidity\nfunction _canRemoveExtension(string memory _extensionName) internal virtual returns (bool);\n```\n\n### \\_canEnableFunctionInExtension\n\n_Returns whether a function can be enabled in an extension in the given execution context._\n\n```solidity\nfunction _canEnableFunctionInExtension(string memory _extensionName, ExtensionFunction memory)\n    internal\n    view\n    virtual\n    returns (bool);\n```\n\n### \\_canDisableFunctionInExtension\n\n_Returns whether a function can be disabled in an extension in the given execution context._\n\n```solidity\nfunction _canDisableFunctionInExtension(string memory _extensionName, bytes4 _functionSelector)\n    internal\n    view\n    virtual\n    returns (bool);\n```\n\n### \\_extensionManagerStorage\n\n_Returns the ExtensionManager storage._\n\n```solidity\nfunction _extensionManagerStorage() internal pure returns (ExtensionManagerStorage.Data storage data);\n```\n\n### isAuthorizedCallToUpgrade\n\n_To override; returns whether all relevant permission and other checks are met before any upgrade._\n\n```solidity\nfunction isAuthorizedCallToUpgrade() internal view virtual returns (bool);\n```\n\n## BaseRouter\n\n```solidity\nimport \"@thirdweb-dev/dynamic-contracts/src/presets/BaseRouter\"\n```\n\n`BaseRouter` inherits `Router` and `ExtensionManager`. It overrides the `Router.getImplementationForFunction` function to use the extensions stored in the `ExtensionManager` contract's storage system.\n\nThis contract is an abstract contract that expects you to override and implement the following functions:\n\n- `isAuthorizedCallToUpgrade`\n  ```solidity\n  function isAuthorizedCallToUpgrade() internal view virtual returns (bool);\n  ```\n\n### getImplementationForFunction\n\nReturns the implementation address to delegateCall for the given function selector.\n\n```solidity\nfunction getImplementationForFunction(bytes4 _functionSelector) public view virtual override returns (address);\n```\n\n**Parameters**\n\n| Name                | Type     | Description                                                  |\n| ------------------- | -------- | ------------------------------------------------------------ |\n| `_functionSelector` | `bytes4` | The function selector to get the implementation address for. |\n\n**Returns**\n\n| Name     | Type      | Description                                                                                |\n| -------- | --------- | ------------------------------------------------------------------------------------------ |\n| `<none>` | `address` | implementation The implementation address to delegateCall for the given function selector. |\n\n# Feedback\n\nThe best, most open way to give feedback/suggestions for the router pattern is to open a github issue, or comment in the ERC-7504 [ethereum-magicians discussion](https://ethereum-magicians.org/t/erc-7504-dynamic-contracts/15551).\n\nAdditionally, since [thirdweb](https://thirdweb.com/) will be maintaining this repository, you can reach out to us at support@thirdweb.com or join our [discord](https://discord.gg/thirdweb).\n\n# Authors\n\n- [thirdweb](https://github.com/thirdweb-dev)\n","scripts":{},"_npmUser":{"name":"krishang","email":"krishang@thirdweb.com"},"repository":{"url":"https://github.com/thirdweb-dev/dynamic-contracts.git","type":"git"},"description":"Architectural pattern for writing dynamic smart contracts in Solidity","directories":{},"dependencies":{},"publishConfig":{"access":"public"},"_hasShrinkwrap":false,"readmeFilename":"README.md","_npmOperationalInternal":{"tmp":"tmp/dynamic-contracts_1.2.1-0_1694543442456_0.2728976421457632","host":"s3://npm-registry-packages"}},"1.2.1-1":{"name":"@thirdweb-dev/dynamic-contracts","version":"1.2.1-1","author":{"name":"thirdweb engineering","email":"eng@thirdweb.com"},"license":"MIT","_id":"@thirdweb-dev/dynamic-contracts@1.2.1-1","maintainers":[{"name":"furqantw","email":"furqan@thirdweb.com"},{"name":"jarrodwatts","email":"jarrodwatts16@gmail.com"},{"name":"yash90","email":"yash@thirdweb.com"},{"name":"nachoiacovino","email":"nacho.iacovino@gmail.com"},{"name":"adam-maj","email":"mr.adam.maj@gmail.com"},{"name":"krishang","email":"krishang@thirdweb.com"},{"name":"abenftlabs","email":"abe@nftlabs.co"},{"name":"jakeloo","email":"jake@nftlabs.co"},{"name":"joaquim-verges","email":"joaquim@thirdweb.com"},{"name":"jnsdls","email":"jonas@thirdweb.com"}],"homepage":"https://thirdweb.com/","bugs":{"url":"https://github.com/thirdweb-dev/dynamic-contracts/issues"},"dist":{"shasum":"f2e404d247f65278ecdad2b74a24fb932f6198c7","tarball":"https://registry.npmjs.org/@thirdweb-dev/dynamic-contracts/-/dynamic-contracts-1.2.1-1.tgz","fileCount":189,"integrity":"sha512-4rM5tvFgrbXoDvfOFZNxQePTGTnfmmmTPoyYYQvVxhfo8ofsddB2xmwdQzknTqd/P1ax9vKO4XpmIM5/JDSlrQ==","signatures":[{"sig":"MEQCIFfdB1A+mzQH6ol6vG2uhFljy91YId9Bu+yA93GoNMXJAiB+xNwQ0EHUlNL2D/4PFfidbOvvbN4ONHcUgRRcNy9JSw==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":55503155},"main":"index.js","readme":"# ERC-7504: Dynamic Contracts standard.\n\n**Architectural pattern for writing client-friendly one-to-many proxy contracts (aka 'dynamic contracts') in Solidity.**\n\nThis repository implements ERC-7504: Dynamic Contracts [[DRAFT](https://ethereum-magicians.org/t/erc-7504-dynamic-contracts/15551)]. This repository provides core interfaces and preset implementations that:\n\n- Provide guardrails for writing dynamic contracts that can have functionality added, updated or removed over time.\n- Enables scaling up contracts by eliminating the restriction of contract size limit altogether.\n\n> ⚠️ **ERC-7504** [DRAFT] is now published and open for feedback! You can read the EIP and provide your feedback at its [ethereum-magicians discussion link](https://ethereum-magicians.org/t/erc-7504-dynamic-contracts/15551).\n\n# Installation\n\n### Forge projects:\n\n```bash\nforge install https://github.com/thirdweb-dev/dynamic-contracts\n```\n\n### Hardhat / JS based projects:\n\n```bash\nnpm install @thirdweb-dev/dynamic-contracts\n```\n\n### Project structure\n\n```shell\nsrc\n|\n|-- core\n|   |- Router: \"Minmal abstract contract implementation of EIP-7504 Router.\"\n|   |- RouterPayable: \"A Router with `receive` as a fixed function.\"\n|\n|-- presets\n|   |-- ExtensionManager: \"Defined storage layout and API for managing a router's extensions.\"\n|   |-- DefaultExtensionSet: \"A static store of a set of extensions, initialized on deployment.\"\n|   |-- BaseRouter: \"A Router with an ExtensionManager.\"\n|   |-- BaseRouterWithDefaults: \"A BaseRouter initialized with extensions on deployment.\"\n|\n|-- interface: \"Interfaces for core and preset contracts.\"\n|-- example: \"Example dynamic contracts built with presets.\"\n|-- lib: \"Storage layouts and helper libraries.\"\n```\n\n# Running locally\n\nThis repository is a forge project. ([forge handbook](https://book.getfoundry.sh/))\n\n**Clone the repository:**\n\n```bash\ngit clone https://github.com/thirdweb-dev/dynamic-contracts.git\n```\n\n**Install dependencies:**\n\n```bash\nforge install\n```\n\n**Compile contracts:**\n\n```bash\nforge build\n```\n\n**Run tests:**\n\n```bash\nforge test\n```\n\n**Generate documentation**\n\n```bash\nforge doc --serve --port 4000\n```\n\n# Core concepts\n\nAn “upgradeable smart contract” is actually two kinds of smart contracts considered together as one system:\n\n1. **Proxy** smart contract: The smart contract whose state/storage we’re concerned with.\n2. **Implementation** smart contract: A stateless smart contract that defines the logic for how the proxy smart contract’s state can be mutated.\n\n![A proxy contract that forwards all calls to a single implementation contract](https://ipfs.io/ipfs/QmdzTiw5YuaMa1rjBtoyDuGHHRLdi9Afmh2Tu9Rjj1XuoA/proxy-with-single-impl.png)\n\nThe job of a proxy contract is to forward any calls it receives to the implementation contract via `delegateCall`. As a shorthand — a proxy contract stores state, and always asks an implementation contract how to mutate its state (upon receiving a call).\n\nERC-7504 introduces a `Router` smart contract.\n\n![A router contract that forwards calls to one of many implementation contracts based on the incoming calldata](https://ipfs.io/ipfs/Qmasd6DHrqMnkhifoapWAeWSs8eEJoFbzKJUpeEBacPAM7/router-many-impls.png)\n\nInstead of always delegateCall-ing the same implementation contract, a `Router` delegateCalls a particular implementation contract (i.e. “Extension”) for the particular function call it receives.\n\nA router stores a map from function selectors → to the implementation contract where the given function is implemented. “Upgrading a contract” now simply means updating what implementation contract a given function, or functions are mapped to.\n\n![Upgrading a contract means updating what implementation a given function, or functions are mapped to](https://ipfs.io/ipfs/QmUWk4VrFsAQ8gSMvTKwPXptJiMjZdihzUNhRXky7VmgGz/router-upgrades.png)\n\n# Getting started\n\nThe simplest way to write a `Router` contract is to extend the preset [`BaseRouter`](/src/presets/BaseRouter.sol) available in this repository.\n\n```solidity\nimport \"lib/dynamic-contracts/src/presets/BaseRouter.sol\";\n```\n\nThe `BaseRouter` contract comes with an API to add/replace/remove extensions from the contract. It is an abstract contract, and expects its consumer to implement the `_isAuthorizedCallToUpgrade` function, which specifies the conditions under which `Extensions` can be added, replaced or removed. The rest of the implementation is generic and usable for all purposes.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@thirdweb-dev/dynamic-contracts/src/presets/BaseRouter.sol\";\n\n/// Example usage of `BaseRouter`, for demonstration only\n\ncontract SimpleRouter is BaseRouter {\n\n    address public deployer;\n\n    constructor() {\n        deployer = msg.sender;\n    }\n\n    /// @dev Returns whether all relevant permission checks are met before any upgrade.\n    function isAuthorizedCallToUpgrade() internal view virtual override returns (bool) {\n        return msg.sender == deployer;\n    }\n}\n```\n\n## Choosing a permission model\n\nThe main decision as a `Router` contract author is to decide the permission model to add/replace/remove extensions. This repository offers some examples of a few possible permission models:\n\n- [**RouterImmutable**](https://github.com/thirdweb-dev/dynamic-contracts/blob/main/src/example/RouterImmutable.sol)\n\n  This is a preset you can use to create static contracts that cannot be updated or get new functionality. This still allows you to create modular contracts that go beyond the contract size limit, but guarantees that the original functionality cannot be altered. With this model, you would pass all the Extensions for this contract at construction time, and guarantee that the functionality is immutable.\n\n- [**RouterUpgradeable**](https://github.com/thirdweb-dev/dynamic-contracts/blob/main/src/example/RouterUpgradeable.sol)\n\n  This a is a preset that allows the contract owner to add / replace / remove extensions. The contract owner can be changed. This is a very basic permission model, but enough for some use cases. You can expand on this and use a permission based model instead for example.\n\n- [**RouterRegistryContrained**](https://github.com/thirdweb-dev/dynamic-contracts/blob/main/src/example/RouterRegistryConstrained.sol)\n\n  This is a preset that allows the owner to change extensions if they are defined on a given registry contract. This is meant to demonstrate how a protocol ecosystem could constrain extensions to known, audited contracts, for instance. The registry and router upgrade models are of course too basic for production as written.\n\n## Writing extension smart contracts\n\nAn `Extension` contract is written like any other smart contract, except that its state must be defined using a `struct` within a `library` and at a well defined storage location. This storage technique is known as [storage structs](https://mirror.xyz/horsefacts.eth/EPB4o-eyDl0N8gu0gEz1uw7BTITheaZUqIAOEK1m-jE).\n\n**Example:** `ExtensionManagerStorage` defines the storage layout for the `ExtensionManager` contract.\n\n```solidity\n// SPDX-License-Identifier: MIT\n// @author: thirdweb (https://github.com/thirdweb-dev/dynamic-contracts)\n\npragma solidity ^0.8.0;\n\nimport \"./StringSet.sol\";\nimport \"../interface/IExtension.sol\";\n\nlibrary ExtensionManagerStorage {\n\n    /// @custom:storage-location erc7201:extension.manager.storage\n    bytes32 public constant EXTENSION_MANAGER_STORAGE_POSITION = keccak256(abi.encode(uint256(keccak256(\"extension.manager.storage\")) - 1));\n\n    struct Data {\n        /// @dev Set of names of all extensions stored.\n        StringSet.Set extensionNames;\n        /// @dev Mapping from extension name => `Extension` i.e. extension metadata and functions.\n        mapping(string => IExtension.Extension) extensions;\n        /// @dev Mapping from function selector => metadata of the extension the function belongs to.\n        mapping(bytes4 => IExtension.ExtensionMetadata) extensionMetadata;\n    }\n\n    function data() internal pure returns (Data storage data_) {\n        bytes32 position = EXTENSION_MANAGER_STORAGE_POSITION;\n        assembly {\n            data_.slot := position\n        }\n    }\n}\n```\n\nEach `Extension` of a router must occupy a unique, unused storage location. This is important to ensure that state updates defined in one `Extension` doesn't conflict with the state updates defined in another `Extension`, leading to corrupted state.\n\n## Extensions: logical grouping of functionality\n\nBy itself, the core `Router` contract does not specify _how to store or fetch_ appropriate implementation addresses for incoming function calls.\n\nWhile the Router pattern allows to point to a different contract for each function, in practice functions are usually groupped by functionality related to a shared state (a read and a set function for example).\n\nTo make the pattern more practical, we created a generic `BaseRouter` contract that makes it easy to have logical group of functions plugged in and out of it, each group of functions being implemented in a separate implementation contract. We refer to each such implementation contract as an **_extension_**.\n\n`BaseRouter` maintains a `function_signature` → `implementation` mapping, and provides an API for updating that mapping. By updating the values stored in this map, functionality can be added to, removed from or updated in the smart contract.\n\n![Upgrading a contract means updating what implementation a given function, or functions are mapped to](https://ipfs.io/ipfs/QmUWk4VrFsAQ8gSMvTKwPXptJiMjZdihzUNhRXky7VmgGz/router-upgrades.png)\n\n## Deploying a Router\n\nDeploying a contract in the router pattern looks a little different from deploying a regular contract.\n\n1. Deploy all your `Extension` contracts first. You only need to do this once per `Extension`. Deployed `Extensions` can be re-used by many different `Router` contracts.\n\n2. Deploy your `Router` contract that implements `BaseRouter`.\n3. Add extensions to youe router via the API available in `BaseRouter`. (Alternatively, you can use `BaseRouterDefaults` which can be initialized with a set of extensions on deployment.)\n\n### `Extensions` - Grouping logical functionality together\n\nBy itself, the core `Router` contract does not specify _how to store or fetch_ appropriate implementation addresses for incoming function calls.\n\nWhile the Router pattern allows to point to a different contract for each function, in practice functions are usually groupped by functionality related to a shared state (a read and a set function for example).\n\nTo make the pattern more practical, we created a generic `BaseRouter` contract that makes it easy to have logical group of functions plugged in and out of it, each group of functions being implemented in a separate implementation contract. We refer to each such implementation contract as an **_extension_**.\n\n`BaseRouter` maintains a `function_signature` → `implementation` mapping, and provides an API for updating that mapping. By updating the values stored in this map, functionality can be added to, removed from or updated in the smart contract.\n\n## Extension to Extension communication\n\nWhen splitting logic between multiple extensions in a `Router`, one might want to access data from one `Extension` to another.\n\nA simple way to do this is by casting the current contract address as the `Extension` (ideally its interface) we're trying to call. This works from both a `Router` or any of its extensions.\n\nHere's an example of accessing a `IPermission` extension from another one:\n\n```solidity\nmodifier onlyAdmin(address _asset) {\n  /// we access our IPermission extension by casting our own address\n  IPermissions(address(this)).hasAdminRole(msg.sender);\n}\n```\n\nNote that if we don't have an `IPermission` extension added to our `Router`, this method will revert.\n\n## Upgrading Extensions\n\nJust like any upgradeable contract, there are limitations on how the data structure of the updated contract is modified. While the logic of a function can be updated safely, changing the data structure of a contract requires careful consideration.\n\nA good rule of thumb to follow is:\n\n- It is safe to append new fields to an existing data structure\n- It is _not_ safe to update the type or order of existing structs; deprecate and add new ones instead.\n\nRefer to [this article](https://mirror.xyz/horsefacts.eth/EPB4o-eyDl0N8gu0gEz1uw7BTITheaZUqIAOEK1m-jE) for more information.\n\n# API reference\n\nYou can generate and view the full API reference for all contracts, interfaces and libraries in the repository by running the repository locally and running:\n\n```bash\nforge doc --serve --port 4000\n```\n\n## Router\n\n```solidity\nimport \"@thirdweb-dev/dynamic-contracts/src/core/Router.sol\";\n```\n\nThe `Router` smart contract implements the ERC-7504 [`Router` interface](https://github.com/thirdweb-dev/dynamic-contracts/blob/main/src/interface/IRouter.sol).\n\nFor any given function call made to the Router contract that reaches the fallback function, the contract performs a delegateCall on the address returned by `getImplementationForFunction(msg.sig)`.\n\nThis is an abstract contract that expects you to override and implement the following functions:\n\n- `getImplementationForFunction`\n  ```solidity\n  function getImplementationForFunction(bytes4 _functionSelector) public view virtual returns (address implementation);\n  ```\n\n### fallback\n\ndelegateCalls the appropriate implementation address for the given incoming function call.\n\n_The implementation address to delegateCall MUST be retrieved from calling `getImplementationForFunction` with the\nincoming call's function selector._\n\n```solidity\nfallback() external payable virtual;\n```\n\n#### Revert conditions:\n\n- `getImplementationForFunction(msg.sig) == address(0)`\n\n### \\_delegate\n\n_delegateCalls an `implementation` smart contract._\n\n```solidity\nfunction _delegate(address implementation) internal virtual;\n```\n\n### getImplementationForFunction\n\nReturns the implementation address to delegateCall for the given function selector.\n\n```solidity\nfunction getImplementationForFunction(bytes4 _functionSelector) public view virtual returns (address implementation);\n```\n\n**Parameters**\n\n| Name                | Type     | Description                                                  |\n| ------------------- | -------- | ------------------------------------------------------------ |\n| `_functionSelector` | `bytes4` | The function selector to get the implementation address for. |\n\n**Returns**\n\n| Name             | Type      | Description                                                                 |\n| ---------------- | --------- | --------------------------------------------------------------------------- |\n| `implementation` | `address` | The implementation address to delegateCall for the given function selector. |\n\n## ExtensionManager\n\n```solidity\nimport \"@thirdweb-dev/dynamic-contracts/src/presets/ExtensionManager.sol\";\n```\n\nThe `ExtensionManager` contract provides a defined storage layout and API for managing and fetching a router's extensions. This contract implements the ERC-7504 [`RouterState` interface](https://github.com/thirdweb-dev/dynamic-contracts/blob/main/src/interface/IRouterState.sol).\n\nThe contract's storage layout is defined in `src/lib/ExtensionManagerStorage`:\n\n```solidity\nstruct Data {\n    StringSet.Set extensionNames;\n    mapping(string => IExtension.Extension) extensions;\n    mapping(bytes4 => IExtension.ExtensionMetadata) extensionMetadata;\n}\n```\n\nThe following are some helpful **invariant properties** of `ExtensionManager`:\n\n- Each extension has a non-empty, unique name which is stored in `extensionNames`.\n- Each extension's metadata specifies a _non_-zero-address implementation.\n- A function `fn` has a non-empty metadata i.e. `extensionMetadata[fn]` value _if and only if_ it is a part of some extension `Ext` such that:\n\n  - `extensionNames` contains `Ext.metadata.name`\n  - `extensions[Ext.metadata.name].functions` includes `fn`.\n\nThis contract is meant to be used along with a Router contract, where an upgrade to the Router means updating the storage of `ExtensionManager`. For example, the preset contract `BaseRouter` inherits `Router` and `ExtensionManager` and overrides the `getImplementationForFunction` function as follows:\n\n```solidity\nfunction getImplementationForFunction(bytes4 _functionSelector) public view virtual override returns (address) {\n        return getMetadataForFunction(_functionSelector).implementation;\n    }\n```\n\nThis contract is an abstract contract that expects you to override and implement the following functions:\n\n- `isAuthorizedCallToUpgrade`\n  ```solidity\n  function isAuthorizedCallToUpgrade() internal view virtual returns (bool);\n  ```\n\n### onlyAuthorizedCall\n\nChecks that a call to any external function is authorized.\n\n```solidity\nmodifier onlyAuthorizedCall();\n```\n\n#### Revert conditions:\n\n- `!_isAuthorizedCallToUpgrade()`\n\n### getAllExtensions\n\nReturns all extensions of the Router.\n\n```solidity\nfunction getAllExtensions() external view virtual override returns (Extension[] memory allExtensions);\n```\n\n**Returns**\n\n| Name            | Type          | Description                 |\n| --------------- | ------------- | --------------------------- |\n| `allExtensions` | `Extension[]` | An array of all extensions. |\n\n### getMetadataForFunction\n\nReturns the extension metadata for a given function.\n\n```solidity\nfunction getMetadataForFunction(bytes4 functionSelector) public view virtual returns (ExtensionMetadata memory);\n```\n\n**Parameters**\n\n| Name               | Type     | Description                                              |\n| ------------------ | -------- | -------------------------------------------------------- |\n| `functionSelector` | `bytes4` | The function selector to get the extension metadata for. |\n\n**Returns**\n\n| Name     | Type                | Description                                           |\n| -------- | ------------------- | ----------------------------------------------------- |\n| `<none>` | `ExtensionMetadata` | metadata The extension metadata for a given function. |\n\n### getExtension\n\nReturns the extension metadata and functions for a given extension.\n\n```solidity\nfunction getExtension(string memory extensionName) public view virtual returns (Extension memory);\n```\n\n**Parameters**\n\n| Name            | Type     | Description                                                      |\n| --------------- | -------- | ---------------------------------------------------------------- |\n| `extensionName` | `string` | The name of the extension to get the metadata and functions for. |\n\n**Returns**\n\n| Name     | Type        | Description                                                 |\n| -------- | ----------- | ----------------------------------------------------------- |\n| `<none>` | `Extension` | The extension metadata and functions for a given extension. |\n\n### addExtension\n\nAdd a new extension to the router.\n\n```solidity\nfunction addExtension(Extension memory _extension) external onlyAuthorizedCall;\n```\n\n**Parameters**\n\n| Name         | Type        | Description           |\n| ------------ | ----------- | --------------------- |\n| `_extension` | `Extension` | The extension to add. |\n\n#### Revert conditions:\n\n- Extension name is empty.\n- Extension name is already used.\n- Extension implementation is zero address.\n- Selector and signature mismatch for some function in the extension.\n- Some function in the extension is already a part of another extension.\n\n### replaceExtension\n\nFully replace an existing extension of the router.\n\n_The extension with name `extension.name` is the extension being replaced._\n\n```solidity\nfunction replaceExtension(Extension memory _extension) external onlyAuthorizedCall;\n```\n\n**Parameters**\n\n| Name         | Type        | Description                            |\n| ------------ | ----------- | -------------------------------------- |\n| `_extension` | `Extension` | The extension to replace or overwrite. |\n\n#### Revert conditions:\n\n- Extension being replaced does not exist.\n- Provided extension's implementation is zero address.\n- Selector and signature mismatch for some function in the provided extension.\n- Some function in the provided extension is already a part of another extension.\n\n### removeExtension\n\nRemove an existing extension from the router.\n\n```solidity\nfunction removeExtension(string memory _extensionName) external onlyAuthorizedCall;\n```\n\n**Parameters**\n\n| Name             | Type     | Description                          |\n| ---------------- | -------- | ------------------------------------ |\n| `_extensionName` | `string` | The name of the extension to remove. |\n\n#### Revert conditions:\n\n- Extension being removed does not exist.\n\n### enableFunctionInExtension\n\nEnables a single function in an existing extension.\n\n_Makes the given function callable on the router._\n\n```solidity\nfunction enableFunctionInExtension(string memory _extensionName, ExtensionFunction memory _function)\n    external\n    onlyAuthorizedCall;\n```\n\n**Parameters**\n\n| Name             | Type                | Description                                               |\n| ---------------- | ------------------- | --------------------------------------------------------- |\n| `_extensionName` | `string`            | The name of the extension to which `extFunction` belongs. |\n| `_function`      | `ExtensionFunction` | The function to enable.                                   |\n\n#### Revert conditions:\n\n- Provided extension does not exist.\n- Selector and signature mismatch for some function in the provided extension.\n- Provided function is already a part of another extension.\n\n### disableFunctionInExtension\n\nDisables a single function in an Extension.\n\n```solidity\nfunction disableFunctionInExtension(string memory _extensionName, bytes4 _functionSelector)\n    external\n    onlyAuthorizedCall;\n```\n\n**Parameters**\n\n| Name                | Type     | Description                                                                    |\n| ------------------- | -------- | ------------------------------------------------------------------------------ |\n| `_extensionName`    | `string` | The name of the extension to which the function of `functionSelector` belongs. |\n| `_functionSelector` | `bytes4` | The function to disable.                                                       |\n\n#### Revert conditions:\n\n- Provided extension does not exist.\n- Provided function is not part of provided extension.\n\n### \\_getExtension\n\n_Returns the Extension for a given name._\n\n```solidity\nfunction _getExtension(string memory _extensionName) internal view returns (Extension memory);\n```\n\n### \\_setMetadataForExtension\n\n_Sets the ExtensionMetadata for a given extension._\n\n```solidity\nfunction _setMetadataForExtension(string memory _extensionName, ExtensionMetadata memory _metadata) internal;\n```\n\n### \\_deleteMetadataForExtension\n\n_Deletes the ExtensionMetadata for a given extension._\n\n```solidity\nfunction _deleteMetadataForExtension(string memory _extensionName) internal;\n```\n\n### \\_setMetadataForFunction\n\n_Sets the ExtensionMetadata for a given function._\n\n```solidity\nfunction _setMetadataForFunction(bytes4 _functionSelector, ExtensionMetadata memory _metadata) internal;\n```\n\n### \\_deleteMetadataForFunction\n\n_Deletes the ExtensionMetadata for a given function._\n\n```solidity\nfunction _deleteMetadataForFunction(bytes4 _functionSelector) internal;\n```\n\n### \\_enableFunctionInExtension\n\n_Enables a function in an Extension._\n\n```solidity\nfunction _enableFunctionInExtension(string memory _extensionName, ExtensionFunction memory _extFunction)\n    internal\n    virtual;\n```\n\n### \\_disableFunctionInExtension\n\nNote: `bytes4(0)` is the function selector for the `receive` function.\nSo, we maintain a special fn selector-signature mismatch check for the `receive` function.\n\n_Disables a given function in an Extension._\n\n```solidity\nfunction _disableFunctionInExtension(string memory _extensionName, bytes4 _functionSelector) internal;\n```\n\n### \\_removeAllFunctionsFromExtension\n\n_Removes all functions from an Extension._\n\n```solidity\nfunction _removeAllFunctionsFromExtension(string memory _extensionName) internal;\n```\n\n### \\_canAddExtension\n\n_Returns whether a new extension can be added in the given execution context._\n\n```solidity\nfunction _canAddExtension(Extension memory _extension) internal virtual returns (bool);\n```\n\n### \\_canReplaceExtension\n\n_Returns whether an extension can be replaced in the given execution context._\n\n```solidity\nfunction _canReplaceExtension(Extension memory _extension) internal virtual returns (bool);\n```\n\n### \\_canRemoveExtension\n\n_Returns whether an extension can be removed in the given execution context._\n\n```solidity\nfunction _canRemoveExtension(string memory _extensionName) internal virtual returns (bool);\n```\n\n### \\_canEnableFunctionInExtension\n\n_Returns whether a function can be enabled in an extension in the given execution context._\n\n```solidity\nfunction _canEnableFunctionInExtension(string memory _extensionName, ExtensionFunction memory)\n    internal\n    view\n    virtual\n    returns (bool);\n```\n\n### \\_canDisableFunctionInExtension\n\n_Returns whether a function can be disabled in an extension in the given execution context._\n\n```solidity\nfunction _canDisableFunctionInExtension(string memory _extensionName, bytes4 _functionSelector)\n    internal\n    view\n    virtual\n    returns (bool);\n```\n\n### \\_extensionManagerStorage\n\n_Returns the ExtensionManager storage._\n\n```solidity\nfunction _extensionManagerStorage() internal pure returns (ExtensionManagerStorage.Data storage data);\n```\n\n### isAuthorizedCallToUpgrade\n\n_To override; returns whether all relevant permission and other checks are met before any upgrade._\n\n```solidity\nfunction isAuthorizedCallToUpgrade() internal view virtual returns (bool);\n```\n\n## BaseRouter\n\n```solidity\nimport \"@thirdweb-dev/dynamic-contracts/src/presets/BaseRouter\"\n```\n\n`BaseRouter` inherits `Router` and `ExtensionManager`. It overrides the `Router.getImplementationForFunction` function to use the extensions stored in the `ExtensionManager` contract's storage system.\n\nThis contract is an abstract contract that expects you to override and implement the following functions:\n\n- `isAuthorizedCallToUpgrade`\n  ```solidity\n  function isAuthorizedCallToUpgrade() internal view virtual returns (bool);\n  ```\n\n### getImplementationForFunction\n\nReturns the implementation address to delegateCall for the given function selector.\n\n```solidity\nfunction getImplementationForFunction(bytes4 _functionSelector) public view virtual override returns (address);\n```\n\n**Parameters**\n\n| Name                | Type     | Description                                                  |\n| ------------------- | -------- | ------------------------------------------------------------ |\n| `_functionSelector` | `bytes4` | The function selector to get the implementation address for. |\n\n**Returns**\n\n| Name     | Type      | Description                                                                                |\n| -------- | --------- | ------------------------------------------------------------------------------------------ |\n| `<none>` | `address` | implementation The implementation address to delegateCall for the given function selector. |\n\n# Feedback\n\nThe best, most open way to give feedback/suggestions for the router pattern is to open a github issue, or comment in the ERC-7504 [ethereum-magicians discussion](https://ethereum-magicians.org/t/erc-7504-dynamic-contracts/15551).\n\nAdditionally, since [thirdweb](https://thirdweb.com/) will be maintaining this repository, you can reach out to us at support@thirdweb.com or join our [discord](https://discord.gg/thirdweb).\n\n# Authors\n\n- [thirdweb](https://github.com/thirdweb-dev)\n","scripts":{},"_npmUser":{"name":"krishang","email":"krishang@thirdweb.com"},"repository":{"url":"https://github.com/thirdweb-dev/dynamic-contracts.git","type":"git"},"description":"Architectural pattern for writing dynamic smart contracts in Solidity","directories":{},"dependencies":{},"publishConfig":{"access":"public"},"_hasShrinkwrap":false,"readmeFilename":"README.md","_npmOperationalInternal":{"tmp":"tmp/dynamic-contracts_1.2.1-1_1694547709954_0.07692769671881772","host":"s3://npm-registry-packages"}},"1.2.1":{"name":"@thirdweb-dev/dynamic-contracts","version":"1.2.1","author":{"name":"thirdweb engineering","email":"eng@thirdweb.com"},"license":"MIT","_id":"@thirdweb-dev/dynamic-contracts@1.2.1","maintainers":[{"name":"furqantw","email":"furqan@thirdweb.com"},{"name":"jarrodwatts","email":"jarrodwatts16@gmail.com"},{"name":"yash90","email":"yash@thirdweb.com"},{"name":"nachoiacovino","email":"nacho.iacovino@gmail.com"},{"name":"adam-maj","email":"mr.adam.maj@gmail.com"},{"name":"krishang","email":"krishang@thirdweb.com"},{"name":"abenftlabs","email":"abe@nftlabs.co"},{"name":"jakeloo","email":"jake@nftlabs.co"},{"name":"joaquim-verges","email":"joaquim@thirdweb.com"},{"name":"jnsdls","email":"jonas@thirdweb.com"}],"homepage":"https://thirdweb.com/","bugs":{"url":"https://github.com/thirdweb-dev/dynamic-contracts/issues"},"dist":{"shasum":"7b677d3f46469e8b30600e090482bebda3241102","tarball":"https://registry.npmjs.org/@thirdweb-dev/dynamic-contracts/-/dynamic-contracts-1.2.1.tgz","fileCount":189,"integrity":"sha512-IFCeETmkmOO4fLOmLtDA6kIABXU8NJ4m3LnUs/f0dooC5A3Yn4sjUIm6CA53alXuyVPUGqi1R7CuCrMYEjpdiA==","signatures":[{"sig":"MEYCIQD9WkWN5tMFe6alCqOePBGEXFvE0K7QHbi16PLrM/fh4wIhAP+TXXwfmeN27ui6PpLxwjP5VBQ2l04o7nMd91ggm5wv","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":55503153},"main":"index.js","scripts":{},"_npmUser":{"name":"krishang","email":"krishang@thirdweb.com"},"repository":{"url":"https://github.com/thirdweb-dev/dynamic-contracts.git","type":"git"},"description":"Architectural pattern for writing dynamic smart contracts in Solidity","directories":{},"dependencies":{},"publishConfig":{"access":"public"},"_hasShrinkwrap":false,"_npmOperationalInternal":{"tmp":"tmp/dynamic-contracts_1.2.1_1694551330551_0.9571988758569523","host":"s3://npm-registry-packages"}},"1.2.2":{"name":"@thirdweb-dev/dynamic-contracts","version":"1.2.2","author":{"name":"thirdweb engineering","email":"eng@thirdweb.com"},"license":"MIT","_id":"@thirdweb-dev/dynamic-contracts@1.2.2","maintainers":[{"name":"furqantw","email":"furqan@thirdweb.com"},{"name":"yash90","email":"yash@thirdweb.com"},{"name":"nachoiacovino","email":"nacho.iacovino@gmail.com"},{"name":"adam-maj","email":"mr.adam.maj@gmail.com"},{"name":"krishang","email":"krishang@thirdweb.com"},{"name":"jakeloo","email":"jake@nftlabs.co"},{"name":"joaquim-verges","email":"joaquim@thirdweb.com"},{"name":"jnsdls","email":"jonas@thirdweb.com"}],"homepage":"https://thirdweb.com/","bugs":{"url":"https://github.com/thirdweb-dev/dynamic-contracts/issues"},"dist":{"shasum":"a86377108c0b160bcd344063a2ac910348167e31","tarball":"https://registry.npmjs.org/@thirdweb-dev/dynamic-contracts/-/dynamic-contracts-1.2.2.tgz","fileCount":210,"integrity":"sha512-0YqcaQ0NLlHNo+/tJf5xQXxor3+0C8nLokVfPT3OFe9OcPmLfSGs7xS7dZdQVwor75CqmNRse29UReU+hd4atw==","signatures":[{"sig":"MEUCIEj08DQIZHR5jFifU9VmKXqpYgORMywo80F9zx18Y5kPAiEA3SdfJfYpdvRjCcW2/MFsyXKaunk0hVD8Bm+xyF/FIIc=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":59555577},"main":"index.js","scripts":{"gas":"forge test --mc Benchmark --gas-report > gasreport.txt"},"_npmUser":{"name":"krishang","email":"krishang@thirdweb.com"},"repository":{"url":"https://github.com/thirdweb-dev/dynamic-contracts.git","type":"git"},"description":"Architectural pattern for writing dynamic smart contracts in Solidity","directories":{},"dependencies":{},"publishConfig":{"access":"public"},"_hasShrinkwrap":false,"_npmOperationalInternal":{"tmp":"tmp/dynamic-contracts_1.2.2_1694712531100_0.026976134883550218","host":"s3://npm-registry-packages"}},"1.2.3":{"name":"@thirdweb-dev/dynamic-contracts","version":"1.2.3","author":{"name":"thirdweb engineering","email":"eng@thirdweb.com"},"license":"MIT","_id":"@thirdweb-dev/dynamic-contracts@1.2.3","maintainers":[{"name":"furqantw","email":"furqan@thirdweb.com"},{"name":"yash90","email":"yash@thirdweb.com"},{"name":"nachoiacovino","email":"nacho.iacovino@gmail.com"},{"name":"adam-maj","email":"mr.adam.maj@gmail.com"},{"name":"krishang","email":"krishang@thirdweb.com"},{"name":"jakeloo","email":"jake@nftlabs.co"},{"name":"joaquim-verges","email":"joaquim@thirdweb.com"},{"name":"jnsdls","email":"jonas@thirdweb.com"}],"homepage":"https://thirdweb.com/","bugs":{"url":"https://github.com/thirdweb-dev/dynamic-contracts/issues"},"dist":{"shasum":"c4dfd386afdbfcbc77598a0d4b5a042c85842e7b","tarball":"https://registry.npmjs.org/@thirdweb-dev/dynamic-contracts/-/dynamic-contracts-1.2.3.tgz","fileCount":211,"integrity":"sha512-qS4GPtOanKTkVnYnWS6kZjK4/tPqUGBhrtz8cksNQD9YSd+SCBs96sEaNbw3/0WpsEvcCX+mKtAvlMIhvwYU5Q==","signatures":[{"sig":"MEQCIEnOVK3hYXlHMw0+wFOIfmk32zq5iNHO4avuLZWOox61AiBjNkIXdc25OgL97CKSzge7J0D2DHZPSXzBLq5HybQTkw==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":59595975},"main":"index.js","scripts":{"gas":"forge test --mc Benchmark --gas-report > gasreport.txt"},"_npmUser":{"name":"krishang","email":"krishang@thirdweb.com"},"repository":{"url":"https://github.com/thirdweb-dev/dynamic-contracts.git","type":"git"},"description":"Architectural pattern for writing dynamic smart contracts in Solidity","directories":{},"dependencies":{},"publishConfig":{"access":"public"},"_hasShrinkwrap":false,"_npmOperationalInternal":{"tmp":"tmp/dynamic-contracts_1.2.3_1695654154604_0.07122358121407779","host":"s3://npm-registry-packages"}},"1.2.4":{"name":"@thirdweb-dev/dynamic-contracts","version":"1.2.4","author":{"name":"thirdweb engineering","email":"eng@thirdweb.com"},"license":"MIT","_id":"@thirdweb-dev/dynamic-contracts@1.2.4","maintainers":[{"name":"furqantw","email":"furqan@thirdweb.com"},{"name":"yash90","email":"yash@thirdweb.com"},{"name":"nachoiacovino","email":"nacho.iacovino@gmail.com"},{"name":"adam-maj","email":"mr.adam.maj@gmail.com"},{"name":"krishang","email":"krishang@thirdweb.com"},{"name":"jakeloo","email":"jake@nftlabs.co"},{"name":"joaquim-verges","email":"joaquim@thirdweb.com"},{"name":"jnsdls","email":"jonas@thirdweb.com"}],"homepage":"https://thirdweb.com/","bugs":{"url":"https://github.com/thirdweb-dev/dynamic-contracts/issues"},"dist":{"shasum":"468de8a98e3be211ad1a0e541da1190093ceca49","tarball":"https://registry.npmjs.org/@thirdweb-dev/dynamic-contracts/-/dynamic-contracts-1.2.4.tgz","fileCount":211,"integrity":"sha512-cQtUznRXBDifzME3zmppVrfBM2Aw8C/okCLzsgcLU/Qr68TjLJTKTDGt2uGo/q5qAvRVJjQRD/bNvV1QTqjqSg==","signatures":[{"sig":"MEUCIQCYWYpBPaHuLrLtSmr3uA7s2wtk2d3EhJRl+vv3mlumzwIgMhMc1szzs/ZHxKikUpNB3pXf+BPkYAofAuUn0K1jl2k=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":59596078},"main":"index.js","scripts":{"gas":"forge test --mc Benchmark --gas-report > gasreport.txt"},"_npmUser":{"name":"krishang","email":"krishang@thirdweb.com"},"repository":{"url":"https://github.com/thirdweb-dev/dynamic-contracts.git","type":"git"},"description":"Architectural pattern for writing dynamic smart contracts in Solidity","directories":{},"dependencies":{},"publishConfig":{"access":"public"},"_hasShrinkwrap":false,"_npmOperationalInternal":{"tmp":"tmp/dynamic-contracts_1.2.4_1695773317298_0.6887053412924453","host":"s3://npm-registry-packages"}},"1.2.5":{"name":"@thirdweb-dev/dynamic-contracts","version":"1.2.5","author":{"name":"thirdweb engineering","email":"eng@thirdweb.com"},"license":"MIT","_id":"@thirdweb-dev/dynamic-contracts@1.2.5","maintainers":[{"name":"adam-maj","email":"mr.adam.maj@gmail.com"},{"name":"furqantw","email":"furqan@thirdweb.com"},{"name":"yash90","email":"yash@thirdweb.com"},{"name":"nachoiacovino","email":"nacho.iacovino@gmail.com"},{"name":"krishang","email":"krishang@thirdweb.com"},{"name":"jakeloo","email":"jake@nftlabs.co"},{"name":"joaquim-verges","email":"joaquim@thirdweb.com"},{"name":"jnsdls","email":"jonas@thirdweb.com"}],"homepage":"https://thirdweb.com/","bugs":{"url":"https://github.com/thirdweb-dev/dynamic-contracts/issues"},"dist":{"shasum":"f9735c0d46198e7bf2f98c277f0a9a79c54da1e8","tarball":"https://registry.npmjs.org/@thirdweb-dev/dynamic-contracts/-/dynamic-contracts-1.2.5.tgz","fileCount":188,"integrity":"sha512-YVsz+jUWbwj+6aF2eTZGMfyw47a1HRmgNl4LQ3gW9gwYL5y5+OX/yOzv6aV5ibvoqCk/k10aIVK2eFrcpMubQA==","signatures":[{"sig":"MEYCIQCuPBExs7qEp6Cqm9JSpW2S7FJFwEKLBPvLDCLPoL4qpAIhAJsFv7ZoWlG9owLOlPM0QimrYGprcENBN8CoJ5L50fOS","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":36745916},"main":"index.js","engines":{"node":">=18.0.0"},"scripts":{"gas":"forge test --mc Benchmark --gas-report > gasreport.txt"},"_npmUser":{"name":"krishang","email":"krishang@thirdweb.com"},"repository":{"url":"https://github.com/thirdweb-dev/dynamic-contracts.git","type":"git"},"description":"Architectural pattern for writing dynamic smart contracts in Solidity","directories":{},"dependencies":{},"publishConfig":{"access":"public"},"_hasShrinkwrap":false,"_npmOperationalInternal":{"tmp":"tmp/dynamic-contracts_1.2.5_1702315440255_0.9380089912214453","host":"s3://npm-registry-packages"}}},"time":{"created":"2023-02-22T18:31:04.284Z","modified":"2024-06-14T18:14:45.447Z","1.0.0":"2023-02-22T18:31:04.498Z","1.0.1":"2023-02-28T22:56:52.644Z","1.0.2":"2023-03-02T19:45:55.510Z","1.0.4":"2023-08-15T19:42:49.540Z","1.1.0":"2023-08-15T21:06:40.764Z","1.1.1":"2023-08-17T23:35:15.382Z","1.1.2-0":"2023-08-18T00:00:37.351Z","1.1.2":"2023-08-18T00:12:19.682Z","1.1.3-0":"2023-08-18T15:09:09.765Z","1.1.3-1":"2023-08-18T15:13:28.378Z","1.1.3":"2023-08-18T15:33:40.753Z","1.1.4-0":"2023-08-18T20:36:36.584Z","1.1.4":"2023-08-18T20:44:11.636Z","1.2.0-0":"2023-09-05T17:23:20.007Z","1.2.0":"2023-09-08T14:46:28.554Z","1.2.1-0":"2023-09-12T18:30:42.782Z","1.2.1-1":"2023-09-12T19:41:50.326Z","1.2.1":"2023-09-12T20:42:10.819Z","1.2.2":"2023-09-14T17:28:51.563Z","1.2.3":"2023-09-25T15:02:34.981Z","1.2.4":"2023-09-27T00:08:37.542Z","1.2.5":"2023-12-11T17:24:00.503Z"},"maintainers":[{"email":"bot@thirdweb.com","name":"thirdweb-bot"},{"email":"furqan@thirdweb.com","name":"furqantw"},{"email":"yash@thirdweb.com","name":"yash90"},{"email":"jake@thirdweb.com","name":"jakeloo"},{"email":"joaquim@thirdweb.com","name":"joaquim-verges"},{"email":"jonas@thirdweb.com","name":"jnsdls"}],"author":{"name":"thirdweb engineering","email":"eng@thirdweb.com"},"repository":{"url":"https://github.com/thirdweb-dev/dynamic-contracts.git","type":"git"},"license":"MIT","homepage":"https://thirdweb.com/","bugs":{"url":"https://github.com/thirdweb-dev/dynamic-contracts/issues"},"readme":"# ERC-7504: Dynamic Contracts standard.\n\n**Architectural pattern for writing client-friendly one-to-many proxy contracts (aka 'dynamic contracts') in Solidity.**\n\nThis repository implements ERC-7504: Dynamic Contracts [[DRAFT](https://ethereum-magicians.org/t/erc-7504-dynamic-contracts/15551)]. This repository provides core interfaces and preset implementations that:\n\n- Provide guardrails for writing dynamic contracts that can have functionality added, updated or removed over time.\n- Enables scaling up contracts by eliminating the restriction of contract size limit altogether.\n\n> ⚠️ **ERC-7504** [DRAFT] is now published and open for feedback! You can read the EIP and provide your feedback at its [ethereum-magicians discussion link](https://ethereum-magicians.org/t/erc-7504-dynamic-contracts/15551).\n\n# Installation\n\n### Forge projects:\n\n```bash\nforge install https://github.com/thirdweb-dev/dynamic-contracts\n```\n\n### Hardhat / JS based projects:\n\n```bash\nnpm install @thirdweb-dev/dynamic-contracts\n```\n\n### Project structure\n\n```shell\nsrc\n|\n|-- core\n|   |- Router: \"Minmal abstract contract implementation of EIP-7504 Router.\"\n|   |- RouterPayable: \"A Router with `receive` as a fixed function.\"\n|\n|-- presets\n|   |-- ExtensionManager: \"Defined storage layout and API for managing a router's extensions.\"\n|   |-- DefaultExtensionSet: \"A static store of a set of extensions, initialized on deployment.\"\n|   |-- BaseRouter: \"A Router with an ExtensionManager.\"\n|   |-- BaseRouterWithDefaults: \"A BaseRouter initialized with extensions on deployment.\"\n|\n|-- interface: \"Interfaces for core and preset contracts.\"\n|-- example: \"Example dynamic contracts built with presets.\"\n|-- lib: \"Storage layouts and helper libraries.\"\n```\n\n# Running locally\n\nThis repository is a forge project. ([forge handbook](https://book.getfoundry.sh/))\n\n**Clone the repository:**\n\n```bash\ngit clone https://github.com/thirdweb-dev/dynamic-contracts.git\n```\n\n**Install dependencies:**\n\n```bash\nforge install\n```\n\n**Compile contracts:**\n\n```bash\nforge build\n```\n\n**Run tests:**\n\n```bash\nforge test\n```\n\n**Generate documentation**\n\n```bash\nforge doc --serve --port 4000\n```\n\n# Core concepts\n\nAn “upgradeable smart contract” is actually two kinds of smart contracts considered together as one system:\n\n1. **Proxy** smart contract: The smart contract whose state/storage we’re concerned with.\n2. **Implementation** smart contract: A stateless smart contract that defines the logic for how the proxy smart contract’s state can be mutated.\n\n![A proxy contract that forwards all calls to a single implementation contract](https://ipfs.io/ipfs/QmdzTiw5YuaMa1rjBtoyDuGHHRLdi9Afmh2Tu9Rjj1XuoA/proxy-with-single-impl.png)\n\nThe job of a proxy contract is to forward any calls it receives to the implementation contract via `delegateCall`. As a shorthand — a proxy contract stores state, and always asks an implementation contract how to mutate its state (upon receiving a call).\n\nERC-7504 introduces a `Router` smart contract.\n\n![A router contract that forwards calls to one of many implementation contracts based on the incoming calldata](https://ipfs.io/ipfs/Qmasd6DHrqMnkhifoapWAeWSs8eEJoFbzKJUpeEBacPAM7/router-many-impls.png)\n\nInstead of always delegateCall-ing the same implementation contract, a `Router` delegateCalls a particular implementation contract (i.e. “Extension”) for the particular function call it receives.\n\nA router stores a map from function selectors → to the implementation contract where the given function is implemented. “Upgrading a contract” now simply means updating what implementation contract a given function, or functions are mapped to.\n\n![Upgrading a contract means updating what implementation a given function, or functions are mapped to](https://ipfs.io/ipfs/QmUWk4VrFsAQ8gSMvTKwPXptJiMjZdihzUNhRXky7VmgGz/router-upgrades.png)\n\n# Getting started\n\nThe simplest way to write a `Router` contract is to extend the preset [`BaseRouter`](/src/presets/BaseRouter.sol) available in this repository.\n\n```solidity\nimport \"lib/dynamic-contracts/src/presets/BaseRouter.sol\";\n```\n\nThe `BaseRouter` contract comes with an API to add/replace/remove extensions from the contract. It is an abstract contract, and expects its consumer to implement the `_isAuthorizedCallToUpgrade` function, which specifies the conditions under which `Extensions` can be added, replaced or removed. The rest of the implementation is generic and usable for all purposes.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@thirdweb-dev/dynamic-contracts/src/presets/BaseRouter.sol\";\n\n/// Example usage of `BaseRouter`, for demonstration only\n\ncontract SimpleRouter is BaseRouter {\n\n    address public deployer;\n\n    constructor() {\n        deployer = msg.sender;\n    }\n\n    /// @dev Returns whether all relevant permission checks are met before any upgrade.\n    function _isAuthorizedCallToUpgrade() internal view virtual override returns (bool) {\n        return msg.sender == deployer;\n    }\n}\n```\n\n## Choosing a permission model\n\nThe main decision as a `Router` contract author is to decide the permission model to add/replace/remove extensions. This repository offers some examples of a few possible permission models:\n\n- [**RouterImmutable**](https://github.com/thirdweb-dev/dynamic-contracts/blob/main/src/example/RouterImmutable.sol)\n\n  This is a preset you can use to create static contracts that cannot be updated or get new functionality. This still allows you to create modular contracts that go beyond the contract size limit, but guarantees that the original functionality cannot be altered. With this model, you would pass all the Extensions for this contract at construction time, and guarantee that the functionality is immutable.\n\n- [**RouterUpgradeable**](https://github.com/thirdweb-dev/dynamic-contracts/blob/main/src/example/RouterUpgradeable.sol)\n\n  This a is a preset that allows the contract owner to add / replace / remove extensions. The contract owner can be changed. This is a very basic permission model, but enough for some use cases. You can expand on this and use a permission based model instead for example.\n\n- [**RouterRegistryContrained**](https://github.com/thirdweb-dev/dynamic-contracts/blob/main/src/example/RouterRegistryConstrained.sol)\n\n  This is a preset that allows the owner to change extensions if they are defined on a given registry contract. This is meant to demonstrate how a protocol ecosystem could constrain extensions to known, audited contracts, for instance. The registry and router upgrade models are of course too basic for production as written.\n\n## Writing extension smart contracts\n\nAn `Extension` contract is written like any other smart contract, except that its state must be defined using a `struct` within a `library` and at a well defined storage location. This storage technique is known as [storage structs](https://mirror.xyz/horsefacts.eth/EPB4o-eyDl0N8gu0gEz1uw7BTITheaZUqIAOEK1m-jE).\n\n**Example:** `ExtensionManagerStorage` defines the storage layout for the `ExtensionManager` contract.\n\n```solidity\n// SPDX-License-Identifier: MIT\n// @author: thirdweb (https://github.com/thirdweb-dev/dynamic-contracts)\n\npragma solidity ^0.8.0;\n\nimport \"./StringSet.sol\";\nimport \"../interface/IExtension.sol\";\n\nlibrary ExtensionManagerStorage {\n\n    /// @custom:storage-location erc7201:extension.manager.storage\n    bytes32 public constant EXTENSION_MANAGER_STORAGE_POSITION = keccak256(abi.encode(uint256(keccak256(\"extension.manager.storage\")) - 1));\n\n    struct Data {\n        /// @dev Set of names of all extensions stored.\n        StringSet.Set extensionNames;\n        /// @dev Mapping from extension name => `Extension` i.e. extension metadata and functions.\n        mapping(string => IExtension.Extension) extensions;\n        /// @dev Mapping from function selector => metadata of the extension the function belongs to.\n        mapping(bytes4 => IExtension.ExtensionMetadata) extensionMetadata;\n    }\n\n    function data() internal pure returns (Data storage data_) {\n        bytes32 position = EXTENSION_MANAGER_STORAGE_POSITION;\n        assembly {\n            data_.slot := position\n        }\n    }\n}\n```\n\nEach `Extension` of a router must occupy a unique, unused storage location. This is important to ensure that state updates defined in one `Extension` doesn't conflict with the state updates defined in another `Extension`, leading to corrupted state.\n\n## Extensions: logical grouping of functionality\n\nBy itself, the core `Router` contract does not specify _how to store or fetch_ appropriate implementation addresses for incoming function calls.\n\nWhile the Router pattern allows to point to a different contract for each function, in practice functions are usually groupped by functionality related to a shared state (a read and a set function for example).\n\nTo make the pattern more practical, we created a generic `BaseRouter` contract that makes it easy to have logical group of functions plugged in and out of it, each group of functions being implemented in a separate implementation contract. We refer to each such implementation contract as an **_extension_**.\n\n`BaseRouter` maintains a `function_signature` → `implementation` mapping, and provides an API for updating that mapping. By updating the values stored in this map, functionality can be added to, removed from or updated in the smart contract.\n\n![Upgrading a contract means updating what implementation a given function, or functions are mapped to](https://ipfs.io/ipfs/QmUWk4VrFsAQ8gSMvTKwPXptJiMjZdihzUNhRXky7VmgGz/router-upgrades.png)\n\n## Deploying a Router\n\nDeploying a contract in the router pattern looks a little different from deploying a regular contract.\n\n1. Deploy all your `Extension` contracts first. You only need to do this once per `Extension`. Deployed `Extensions` can be re-used by many different `Router` contracts.\n\n2. Deploy your `Router` contract that implements `BaseRouter`.\n3. Add extensions to youe router via the API available in `BaseRouter`. (Alternatively, you can use `BaseRouterDefaults` which can be initialized with a set of extensions on deployment.)\n\n### `Extensions` - Grouping logical functionality together\n\nBy itself, the core `Router` contract does not specify _how to store or fetch_ appropriate implementation addresses for incoming function calls.\n\nWhile the Router pattern allows to point to a different contract for each function, in practice functions are usually groupped by functionality related to a shared state (a read and a set function for example).\n\nTo make the pattern more practical, we created a generic `BaseRouter` contract that makes it easy to have logical group of functions plugged in and out of it, each group of functions being implemented in a separate implementation contract. We refer to each such implementation contract as an **_extension_**.\n\n`BaseRouter` maintains a `function_signature` → `implementation` mapping, and provides an API for updating that mapping. By updating the values stored in this map, functionality can be added to, removed from or updated in the smart contract.\n\n## Extension to Extension communication\n\nWhen splitting logic between multiple extensions in a `Router`, one might want to access data from one `Extension` to another.\n\nA simple way to do this is by casting the current contract address as the `Extension` (ideally its interface) we're trying to call. This works from both a `Router` or any of its extensions.\n\nHere's an example of accessing a `IPermission` extension from another one:\n\n```solidity\nmodifier onlyAdmin(address _asset) {\n  /// we access our IPermission extension by casting our own address\n  IPermissions(address(this)).hasAdminRole(msg.sender);\n}\n```\n\nNote that if we don't have an `IPermission` extension added to our `Router`, this method will revert.\n\n## Upgrading Extensions\n\nJust like any upgradeable contract, there are limitations on how the data structure of the updated contract is modified. While the logic of a function can be updated safely, changing the data structure of a contract requires careful consideration.\n\nA good rule of thumb to follow is:\n\n- It is safe to append new fields to an existing data structure\n- It is _not_ safe to update the type or order of existing structs; deprecate and add new ones instead.\n\nRefer to [this article](https://mirror.xyz/horsefacts.eth/EPB4o-eyDl0N8gu0gEz1uw7BTITheaZUqIAOEK1m-jE) for more information.\n\n# API reference\n\nYou can generate and view the full API reference for all contracts, interfaces and libraries in the repository by running the repository locally and running:\n\n```bash\nforge doc --serve --port 4000\n```\n\n## Router\n\n```solidity\nimport \"@thirdweb-dev/dynamic-contracts/src/core/Router.sol\";\n```\n\nThe `Router` smart contract implements the ERC-7504 [`Router` interface](https://github.com/thirdweb-dev/dynamic-contracts/blob/main/src/interface/IRouter.sol).\n\nFor any given function call made to the Router contract that reaches the fallback function, the contract performs a delegateCall on the address returned by `getImplementationForFunction(msg.sig)`.\n\nThis is an abstract contract that expects you to override and implement the following functions:\n\n- `getImplementationForFunction`\n  ```solidity\n  function getImplementationForFunction(bytes4 _functionSelector) public view virtual returns (address implementation);\n  ```\n\n### fallback\n\ndelegateCalls the appropriate implementation address for the given incoming function call.\n\n_The implementation address to delegateCall MUST be retrieved from calling `getImplementationForFunction` with the\nincoming call's function selector._\n\n```solidity\nfallback() external payable virtual;\n```\n\n#### Revert conditions:\n\n- `getImplementationForFunction(msg.sig) == address(0)`\n\n### \\_delegate\n\n_delegateCalls an `implementation` smart contract._\n\n```solidity\nfunction _delegate(address implementation) internal virtual;\n```\n\n### getImplementationForFunction\n\nReturns the implementation address to delegateCall for the given function selector.\n\n```solidity\nfunction getImplementationForFunction(bytes4 _functionSelector) public view virtual returns (address implementation);\n```\n\n**Parameters**\n\n| Name                | Type     | Description                                                  |\n| ------------------- | -------- | ------------------------------------------------------------ |\n| `_functionSelector` | `bytes4` | The function selector to get the implementation address for. |\n\n**Returns**\n\n| Name             | Type      | Description                                                                 |\n| ---------------- | --------- | --------------------------------------------------------------------------- |\n| `implementation` | `address` | The implementation address to delegateCall for the given function selector. |\n\n## ExtensionManager\n\n```solidity\nimport \"@thirdweb-dev/dynamic-contracts/src/presets/ExtensionManager.sol\";\n```\n\nThe `ExtensionManager` contract provides a defined storage layout and API for managing and fetching a router's extensions. This contract implements the ERC-7504 [`RouterState` interface](https://github.com/thirdweb-dev/dynamic-contracts/blob/main/src/interface/IRouterState.sol).\n\nThe contract's storage layout is defined in `src/lib/ExtensionManagerStorage`:\n\n```solidity\nstruct Data {\n    StringSet.Set extensionNames;\n    mapping(string => IExtension.Extension) extensions;\n    mapping(bytes4 => IExtension.ExtensionMetadata) extensionMetadata;\n}\n```\n\nThe following are some helpful **invariant properties** of `ExtensionManager`:\n\n- Each extension has a non-empty, unique name which is stored in `extensionNames`.\n- Each extension's metadata specifies a _non_-zero-address implementation.\n- A function `fn` has a non-empty metadata i.e. `extensionMetadata[fn]` value _if and only if_ it is a part of some extension `Ext` such that:\n\n  - `extensionNames` contains `Ext.metadata.name`\n  - `extensions[Ext.metadata.name].functions` includes `fn`.\n\nThis contract is meant to be used along with a Router contract, where an upgrade to the Router means updating the storage of `ExtensionManager`. For example, the preset contract `BaseRouter` inherits `Router` and `ExtensionManager` and overrides the `getImplementationForFunction` function as follows:\n\n```solidity\nfunction getImplementationForFunction(bytes4 _functionSelector) public view virtual override returns (address) {\n        return getMetadataForFunction(_functionSelector).implementation;\n    }\n```\n\nThis contract is an abstract contract that expects you to override and implement the following functions:\n\n- `isAuthorizedCallToUpgrade`\n  ```solidity\n  function _isAuthorizedCallToUpgrade() internal view virtual returns (bool);\n  ```\n\n### onlyAuthorizedCall\n\nChecks that a call to any external function is authorized.\n\n```solidity\nmodifier onlyAuthorizedCall();\n```\n\n#### Revert conditions:\n\n- `!_isAuthorizedCallToUpgrade()`\n\n### getAllExtensions\n\nReturns all extensions of the Router.\n\n```solidity\nfunction getAllExtensions() external view virtual override returns (Extension[] memory allExtensions);\n```\n\n**Returns**\n\n| Name            | Type          | Description                 |\n| --------------- | ------------- | --------------------------- |\n| `allExtensions` | `Extension[]` | An array of all extensions. |\n\n### getMetadataForFunction\n\nReturns the extension metadata for a given function.\n\n```solidity\nfunction getMetadataForFunction(bytes4 functionSelector) public view virtual returns (ExtensionMetadata memory);\n```\n\n**Parameters**\n\n| Name               | Type     | Description                                              |\n| ------------------ | -------- | -------------------------------------------------------- |\n| `functionSelector` | `bytes4` | The function selector to get the extension metadata for. |\n\n**Returns**\n\n| Name     | Type                | Description                                           |\n| -------- | ------------------- | ----------------------------------------------------- |\n| `<none>` | `ExtensionMetadata` | metadata The extension metadata for a given function. |\n\n### getExtension\n\nReturns the extension metadata and functions for a given extension.\n\n```solidity\nfunction getExtension(string memory extensionName) public view virtual returns (Extension memory);\n```\n\n**Parameters**\n\n| Name            | Type     | Description                                                      |\n| --------------- | -------- | ---------------------------------------------------------------- |\n| `extensionName` | `string` | The name of the extension to get the metadata and functions for. |\n\n**Returns**\n\n| Name     | Type        | Description                                                 |\n| -------- | ----------- | ----------------------------------------------------------- |\n| `<none>` | `Extension` | The extension metadata and functions for a given extension. |\n\n### addExtension\n\nAdd a new extension to the router.\n\n```solidity\nfunction addExtension(Extension memory _extension) external onlyAuthorizedCall;\n```\n\n**Parameters**\n\n| Name         | Type        | Description           |\n| ------------ | ----------- | --------------------- |\n| `_extension` | `Extension` | The extension to add. |\n\n#### Revert conditions:\n\n- Extension name is empty.\n- Extension name is already used.\n- Extension implementation is zero address.\n- Selector and signature mismatch for some function in the extension.\n- Some function in the extension is already a part of another extension.\n\n### replaceExtension\n\nFully replace an existing extension of the router.\n\n_The extension with name `extension.name` is the extension being replaced._\n\n```solidity\nfunction replaceExtension(Extension memory _extension) external onlyAuthorizedCall;\n```\n\n**Parameters**\n\n| Name         | Type        | Description                            |\n| ------------ | ----------- | -------------------------------------- |\n| `_extension` | `Extension` | The extension to replace or overwrite. |\n\n#### Revert conditions:\n\n- Extension being replaced does not exist.\n- Provided extension's implementation is zero address.\n- Selector and signature mismatch for some function in the provided extension.\n- Some function in the provided extension is already a part of another extension.\n\n### removeExtension\n\nRemove an existing extension from the router.\n\n```solidity\nfunction removeExtension(string memory _extensionName) external onlyAuthorizedCall;\n```\n\n**Parameters**\n\n| Name             | Type     | Description                          |\n| ---------------- | -------- | ------------------------------------ |\n| `_extensionName` | `string` | The name of the extension to remove. |\n\n#### Revert conditions:\n\n- Extension being removed does not exist.\n\n### enableFunctionInExtension\n\nEnables a single function in an existing extension.\n\n_Makes the given function callable on the router._\n\n```solidity\nfunction enableFunctionInExtension(string memory _extensionName, ExtensionFunction memory _function)\n    external\n    onlyAuthorizedCall;\n```\n\n**Parameters**\n\n| Name             | Type                | Description                                               |\n| ---------------- | ------------------- | --------------------------------------------------------- |\n| `_extensionName` | `string`            | The name of the extension to which `extFunction` belongs. |\n| `_function`      | `ExtensionFunction` | The function to enable.                                   |\n\n#### Revert conditions:\n\n- Provided extension does not exist.\n- Selector and signature mismatch for some function in the provided extension.\n- Provided function is already a part of another extension.\n\n### disableFunctionInExtension\n\nDisables a single function in an Extension.\n\n```solidity\nfunction disableFunctionInExtension(string memory _extensionName, bytes4 _functionSelector)\n    external\n    onlyAuthorizedCall;\n```\n\n**Parameters**\n\n| Name                | Type     | Description                                                                    |\n| ------------------- | -------- | ------------------------------------------------------------------------------ |\n| `_extensionName`    | `string` | The name of the extension to which the function of `functionSelector` belongs. |\n| `_functionSelector` | `bytes4` | The function to disable.                                                       |\n\n#### Revert conditions:\n\n- Provided extension does not exist.\n- Provided function is not part of provided extension.\n\n### \\_getExtension\n\n_Returns the Extension for a given name._\n\n```solidity\nfunction _getExtension(string memory _extensionName) internal view returns (Extension memory);\n```\n\n### \\_setMetadataForExtension\n\n_Sets the ExtensionMetadata for a given extension._\n\n```solidity\nfunction _setMetadataForExtension(string memory _extensionName, ExtensionMetadata memory _metadata) internal;\n```\n\n### \\_deleteMetadataForExtension\n\n_Deletes the ExtensionMetadata for a given extension._\n\n```solidity\nfunction _deleteMetadataForExtension(string memory _extensionName) internal;\n```\n\n### \\_setMetadataForFunction\n\n_Sets the ExtensionMetadata for a given function._\n\n```solidity\nfunction _setMetadataForFunction(bytes4 _functionSelector, ExtensionMetadata memory _metadata) internal;\n```\n\n### \\_deleteMetadataForFunction\n\n_Deletes the ExtensionMetadata for a given function._\n\n```solidity\nfunction _deleteMetadataForFunction(bytes4 _functionSelector) internal;\n```\n\n### \\_enableFunctionInExtension\n\n_Enables a function in an Extension._\n\n```solidity\nfunction _enableFunctionInExtension(string memory _extensionName, ExtensionFunction memory _extFunction)\n    internal\n    virtual;\n```\n\n### \\_disableFunctionInExtension\n\nNote: `bytes4(0)` is the function selector for the `receive` function.\nSo, we maintain a special fn selector-signature mismatch check for the `receive` function.\n\n_Disables a given function in an Extension._\n\n```solidity\nfunction _disableFunctionInExtension(string memory _extensionName, bytes4 _functionSelector) internal;\n```\n\n### \\_removeAllFunctionsFromExtension\n\n_Removes all functions from an Extension._\n\n```solidity\nfunction _removeAllFunctionsFromExtension(string memory _extensionName) internal;\n```\n\n### \\_canAddExtension\n\n_Returns whether a new extension can be added in the given execution context._\n\n```solidity\nfunction _canAddExtension(Extension memory _extension) internal virtual returns (bool);\n```\n\n### \\_canReplaceExtension\n\n_Returns whether an extension can be replaced in the given execution context._\n\n```solidity\nfunction _canReplaceExtension(Extension memory _extension) internal virtual returns (bool);\n```\n\n### \\_canRemoveExtension\n\n_Returns whether an extension can be removed in the given execution context._\n\n```solidity\nfunction _canRemoveExtension(string memory _extensionName) internal virtual returns (bool);\n```\n\n### \\_canEnableFunctionInExtension\n\n_Returns whether a function can be enabled in an extension in the given execution context._\n\n```solidity\nfunction _canEnableFunctionInExtension(string memory _extensionName, ExtensionFunction memory)\n    internal\n    view\n    virtual\n    returns (bool);\n```\n\n### \\_canDisableFunctionInExtension\n\n_Returns whether a function can be disabled in an extension in the given execution context._\n\n```solidity\nfunction _canDisableFunctionInExtension(string memory _extensionName, bytes4 _functionSelector)\n    internal\n    view\n    virtual\n    returns (bool);\n```\n\n### \\_extensionManagerStorage\n\n_Returns the ExtensionManager storage._\n\n```solidity\nfunction _extensionManagerStorage() internal pure returns (ExtensionManagerStorage.Data storage data);\n```\n\n### isAuthorizedCallToUpgrade\n\n_To override; returns whether all relevant permission and other checks are met before any upgrade._\n\n```solidity\nfunction _isAuthorizedCallToUpgrade() internal view virtual returns (bool);\n```\n\n## BaseRouter\n\n```solidity\nimport \"@thirdweb-dev/dynamic-contracts/src/presets/BaseRouter\"\n```\n\n`BaseRouter` inherits `Router` and `ExtensionManager`. It overrides the `Router.getImplementationForFunction` function to use the extensions stored in the `ExtensionManager` contract's storage system.\n\nThis contract is an abstract contract that expects you to override and implement the following functions:\n\n- `isAuthorizedCallToUpgrade`\n  ```solidity\n  function _isAuthorizedCallToUpgrade() internal view virtual returns (bool);\n  ```\n\n### getImplementationForFunction\n\nReturns the implementation address to delegateCall for the given function selector.\n\n```solidity\nfunction getImplementationForFunction(bytes4 _functionSelector) public view virtual override returns (address);\n```\n\n**Parameters**\n\n| Name                | Type     | Description                                                  |\n| ------------------- | -------- | ------------------------------------------------------------ |\n| `_functionSelector` | `bytes4` | The function selector to get the implementation address for. |\n\n**Returns**\n\n| Name     | Type      | Description                                                                                |\n| -------- | --------- | ------------------------------------------------------------------------------------------ |\n| `<none>` | `address` | implementation The implementation address to delegateCall for the given function selector. |\n\n# Feedback\n\nThe best, most open way to give feedback/suggestions for the router pattern is to open a github issue, or comment in the ERC-7504 [ethereum-magicians discussion](https://ethereum-magicians.org/t/erc-7504-dynamic-contracts/15551).\n\nAdditionally, since [thirdweb](https://thirdweb.com/) will be maintaining this repository, you can reach out to us at support@thirdweb.com or join our [discord](https://discord.gg/thirdweb).\n\n# Authors\n\n- [thirdweb](https://github.com/thirdweb-dev)\n","readmeFilename":"README.md"}