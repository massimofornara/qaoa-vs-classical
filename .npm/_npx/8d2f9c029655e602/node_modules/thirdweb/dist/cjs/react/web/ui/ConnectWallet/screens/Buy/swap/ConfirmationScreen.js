"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectorLine = void 0;
exports.SwapConfirmationScreen = SwapConfirmationScreen;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const pay_js_1 = require("../../../../../../../analytics/track/pay.js");
const contract_js_1 = require("../../../../../../../contract/contract.js");
const approve_js_1 = require("../../../../../../../extensions/erc20/write/approve.js");
const send_batch_transaction_js_1 = require("../../../../../../../transaction/actions/send-batch-transaction.js");
const send_transaction_js_1 = require("../../../../../../../transaction/actions/send-transaction.js");
const wait_for_tx_receipt_js_1 = require("../../../../../../../transaction/actions/wait-for-tx-receipt.js");
const CustomThemeProvider_js_1 = require("../../../../../../core/design-system/CustomThemeProvider.js");
const basic_js_1 = require("../../../../components/basic.js");
const buttons_js_1 = require("../../../../components/buttons.js");
const Spacer_js_1 = require("../../../../components/Spacer.js");
const Spinner_js_1 = require("../../../../components/Spinner.js");
const StepBar_js_1 = require("../../../../components/StepBar.js");
const SwitchNetwork_js_1 = require("../../../../components/SwitchNetwork.js");
const text_js_1 = require("../../../../components/text.js");
const elements_js_1 = require("../../../../design-system/elements.js");
const Stepper_js_1 = require("../Stepper.js");
const ErrorText_js_1 = require("./ErrorText.js");
const pendingSwapTx_js_1 = require("./pendingSwapTx.js");
const SwapSummary_js_1 = require("./SwapSummary.js");
/**
 * @internal
 */
function SwapConfirmationScreen(props) {
    const approveTxRequired = props.quote.approvalData &&
        props.preApprovedAmount !== undefined &&
        props.preApprovedAmount < BigInt(props.quote.approvalData.amountWei);
    const needsApprovalStep = approveTxRequired && !props.payer.account.sendBatchTransaction;
    const initialStep = needsApprovalStep ? "approval" : "swap";
    const [step, setStep] = (0, react_1.useState)(initialStep);
    const [error, setError] = (0, react_1.useState)();
    const [status, setStatus] = (0, react_1.useState)("idle");
    const receiver = props.quote.swapDetails.toAddress;
    const sender = props.quote.swapDetails.fromAddress;
    const uiErrorMessage = (0, react_1.useMemo)(() => {
        if (step === "approval" && status === "error" && error) {
            if (error.toLowerCase().includes("user rejected") ||
                error.toLowerCase().includes("user closed modal") ||
                error.toLowerCase().includes("user denied")) {
                return {
                    message: "Your wallet rejected the approval request.",
                    title: "Failed to Approve",
                };
            }
            if (error.toLowerCase().includes("insufficient funds for gas")) {
                return {
                    message: "You do not have enough native funds to approve the transaction.",
                    title: "Insufficient Native Funds",
                };
            }
            return {
                message: "Your wallet failed to approve the transaction for an unknown reason. Please try again or contact support.",
                title: "Failed to Approve",
            };
        }
        if (step === "swap" && status === "error" && error) {
            if (error.toLowerCase().includes("user rejected") ||
                error.toLowerCase().includes("user closed modal") ||
                error.toLowerCase().includes("user denied")) {
                return {
                    message: "Your wallet rejected the confirmation request.",
                    title: "Failed to Confirm",
                };
            }
            if (error.toLowerCase().includes("insufficient funds for gas")) {
                return {
                    message: "You do not have enough native funds to confirm the transaction.",
                    title: "Insufficient Native Funds",
                };
            }
            return {
                message: "Your wallet failed to confirm the transaction for an unknown reason. Please try again or contact support.",
                title: "Failed to Confirm",
            };
        }
        return undefined;
    }, [error, step, status]);
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { p: "lg", children: [(0, jsx_runtime_1.jsx)(basic_js_1.ModalHeader, { onBack: props.onBack, title: props.title }), props.isFiatFlow ? ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" }), (0, jsx_runtime_1.jsx)(StepBar_js_1.StepBar, { currentStep: 2, steps: 2 }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "sm" }), (0, jsx_runtime_1.jsxs)(text_js_1.Text, { size: "xs", children: ["Step 2 of 2 - Converting ", props.fromTokenSymbol, " to", " ", props.toTokenSymbol] }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" })] })) : ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "sm", children: "Confirm payment" }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" })] })), (0, jsx_runtime_1.jsx)(SwapSummary_js_1.SwapSummary, { client: props.client, fromAmount: props.fromAmount, fromChain: props.fromChain, fromToken: props.fromToken, receiver: receiver, sender: sender, toAmount: props.toAmount, toChain: props.toChain, toToken: props.toToken }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" }), needsApprovalStep && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "sm" }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { center: "y", color: "accentText", flex: "row", gap: "sm", style: {
                            justifyContent: "space-between",
                        }, children: [(0, jsx_runtime_1.jsx)(Stepper_js_1.Step, { isActive: step === "approval", isDone: step === "swap", label: step === "approval" ? "Approve" : "Approved" }), (0, jsx_runtime_1.jsx)(exports.ConnectorLine, {}), (0, jsx_runtime_1.jsx)(Stepper_js_1.Step, { isActive: step === "swap", isDone: false, label: "Confirm" })] }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" })] })), uiErrorMessage && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(ErrorText_js_1.ErrorText, { message: uiErrorMessage.message, title: uiErrorMessage.title }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" })] })), props.payer.chain.id !== props.fromChain.id ? ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xs" }), (0, jsx_runtime_1.jsx)(SwitchNetwork_js_1.SwitchNetworkButton, { fullWidth: true, switchChain: async () => {
                            await props.payer.wallet.switchChain(props.fromChain);
                        }, variant: "accent" })] })) : ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xs" }), (0, jsx_runtime_1.jsxs)(buttons_js_1.Button, { disabled: status === "pending", fullWidth: true, gap: "xs", onClick: async () => {
                            const wallet = props.payer.wallet;
                            // in case the wallet is not on the same chain as the fromToken, switch to it
                            if (wallet.getChain()?.id !== props.fromChain.id) {
                                await wallet.switchChain(props.fromChain);
                            }
                            const account = wallet.getAccount();
                            if (!account) {
                                throw new Error("Payer wallet has no account");
                            }
                            if (step === "approval" && props.quote.approvalData) {
                                try {
                                    setStatus("pending");
                                    (0, pay_js_1.trackPayEvent)({
                                        amountWei: props.quote.swapDetails.fromAmountWei,
                                        chainId: props.quote.swapDetails.fromToken.chainId,
                                        client: props.client,
                                        event: "prompt_swap_approval",
                                        fromToken: props.quote.swapDetails.fromToken.tokenAddress,
                                        toChainId: props.quote.swapDetails.toToken.chainId,
                                        toToken: props.quote.swapDetails.toToken.tokenAddress,
                                        walletAddress: account.address,
                                        walletType: wallet.id,
                                    });
                                    const transaction = (0, approve_js_1.approve)({
                                        amountWei: BigInt(props.quote.approvalData.amountWei),
                                        contract: (0, contract_js_1.getContract)({
                                            address: props.quote.swapDetails.fromToken.tokenAddress,
                                            chain: props.fromChain,
                                            client: props.client,
                                        }),
                                        spender: props.quote.approvalData.spenderAddress,
                                    });
                                    const tx = await (0, send_transaction_js_1.sendTransaction)({
                                        account: account,
                                        transaction,
                                    });
                                    await (0, wait_for_tx_receipt_js_1.waitForReceipt)({ ...tx, maxBlocksWaitTime: 50 });
                                    (0, pay_js_1.trackPayEvent)({
                                        amountWei: props.quote.swapDetails.fromAmountWei,
                                        chainId: props.quote.swapDetails.fromToken.chainId,
                                        client: props.client,
                                        event: "swap_approval_success",
                                        fromToken: props.quote.swapDetails.fromToken.tokenAddress,
                                        toChainId: props.quote.swapDetails.toToken.chainId,
                                        toToken: props.quote.swapDetails.toToken.tokenAddress,
                                        walletAddress: account.address,
                                        walletType: wallet.id,
                                    });
                                    setStep("swap");
                                    setStatus("idle");
                                }
                                catch (e) {
                                    console.error(e);
                                    setError(e.message);
                                    setStatus("error");
                                }
                            }
                            if (step === "swap") {
                                setStatus("pending");
                                try {
                                    (0, pay_js_1.trackPayEvent)({
                                        amountWei: props.quote.swapDetails.fromAmountWei,
                                        chainId: props.quote.swapDetails.fromToken.chainId,
                                        client: props.client,
                                        event: "prompt_swap_execution",
                                        fromToken: props.quote.swapDetails.fromToken.tokenAddress,
                                        toChainId: props.quote.swapDetails.toToken.chainId,
                                        toToken: props.quote.swapDetails.toToken.tokenAddress,
                                        walletAddress: account.address,
                                        walletType: wallet.id,
                                    });
                                    const tx = props.quote.transactionRequest;
                                    let _swapTx;
                                    // check if we can batch approval and swap
                                    const canBatch = account.sendBatchTransaction;
                                    if (canBatch &&
                                        props.quote.approvalData &&
                                        approveTxRequired) {
                                        const approveTx = (0, approve_js_1.approve)({
                                            amountWei: BigInt(props.quote.approvalData.amountWei),
                                            contract: (0, contract_js_1.getContract)({
                                                address: props.quote.swapDetails.fromToken.tokenAddress,
                                                chain: props.fromChain,
                                                client: props.client,
                                            }),
                                            spender: props.quote.approvalData.spenderAddress,
                                        });
                                        _swapTx = await (0, send_batch_transaction_js_1.sendBatchTransaction)({
                                            account: account,
                                            transactions: [approveTx, tx],
                                        });
                                    }
                                    else {
                                        _swapTx = await (0, send_transaction_js_1.sendTransaction)({
                                            account: account,
                                            transaction: tx,
                                        });
                                    }
                                    (0, pay_js_1.trackPayEvent)({
                                        amountWei: props.quote.swapDetails.fromAmountWei,
                                        chainId: props.quote.swapDetails.fromToken.chainId,
                                        client: props.client,
                                        event: "swap_execution_success",
                                        fromToken: props.quote.swapDetails.fromToken.tokenAddress,
                                        toChainId: props.quote.swapDetails.toToken.chainId,
                                        toToken: props.quote.swapDetails.toToken.tokenAddress,
                                        walletAddress: account.address,
                                        walletType: wallet.id,
                                    });
                                    // do not add pending tx if the swap is part of fiat flow
                                    if (!props.isFiatFlow) {
                                        (0, pendingSwapTx_js_1.addPendingTx)({
                                            chainId: _swapTx.chain.id,
                                            txHash: _swapTx.transactionHash,
                                            type: "swap",
                                        });
                                    }
                                    props.setSwapTxHash(_swapTx.transactionHash);
                                }
                                catch (e) {
                                    console.error(e);
                                    setStatus("error");
                                    setError(e.message);
                                }
                            }
                        }, variant: "accent", children: [step === "approval" &&
                                (status === "pending" ? "Approving" : "Approve"), step === "swap" &&
                                (status === "pending" ? "Confirming" : "Confirm"), status === "pending" && ((0, jsx_runtime_1.jsx)(Spinner_js_1.Spinner, { color: "accentButtonText", size: "sm" }))] })] }))] }));
}
exports.ConnectorLine = (0, elements_js_1.StyledDiv)(() => {
    const theme = (0, CustomThemeProvider_js_1.useCustomTheme)();
    return {
        background: theme.colors.borderColor,
        flex: 1,
        height: "4px",
    };
});
//# sourceMappingURL=ConfirmationScreen.js.map