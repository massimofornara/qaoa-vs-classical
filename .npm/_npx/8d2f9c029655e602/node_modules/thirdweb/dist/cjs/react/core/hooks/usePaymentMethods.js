"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.usePaymentMethods = usePaymentMethods;
const react_query_1 = require("@tanstack/react-query");
const Routes_js_1 = require("../../../bridge/Routes.js");
const utils_js_1 = require("../../../chains/utils.js");
const common_js_1 = require("../../../insight/common.js");
const get_tokens_js_1 = require("../../../insight/get-tokens.js");
const units_js_1 = require("../../../utils/units.js");
const useActiveWallet_js_1 = require("./wallets/useActiveWallet.js");
/**
 * Hook that returns available payment methods for BridgeEmbed
 * Fetches real routes data based on the destination token
 *
 * @param options - Configuration options
 * @param options.destinationToken - The destination token to find routes for
 * @param options.client - ThirdwebClient for API calls
 * @returns Available payment methods with route data
 *
 * @example
 * ```tsx
 * const { data: paymentMethods, isLoading, error } = usePaymentMethods({
 *   destinationToken,
 *   client
 * });
 * ```
 */
function usePaymentMethods(options) {
    const { destinationToken, destinationAmount, client, payerWallet, includeDestinationToken, } = options;
    const localWallet = (0, useActiveWallet_js_1.useActiveWallet)(); // TODO (bridge): get all connected wallets
    const wallet = payerWallet || localWallet;
    const routesQuery = (0, react_query_1.useQuery)({
        enabled: !!wallet,
        queryFn: async () => {
            if (!wallet) {
                throw new Error("No wallet connected");
            }
            const allRoutes = await (0, Routes_js_1.routes)({
                client,
                destinationChainId: destinationToken.chainId,
                destinationTokenAddress: destinationToken.address,
                includePrices: true,
                limit: 100,
                maxSteps: 3,
                sortBy: "popularity", // Get top 100 most popular routes
            });
            const allOriginTokens = includeDestinationToken
                ? [destinationToken, ...allRoutes.map((route) => route.originToken)]
                : allRoutes.map((route) => route.originToken);
            // 1. Resolve all unique chains in the supported token map
            const uniqueChains = Array.from(new Set(allOriginTokens.map((t) => t.chainId)));
            // 2. Check insight availability once per chain
            const insightSupport = await Promise.all(uniqueChains.map(async (c) => ({
                chain: (0, utils_js_1.getCachedChain)(c),
                enabled: await (0, common_js_1.isInsightEnabled)((0, utils_js_1.getCachedChain)(c)),
            })));
            const insightEnabledChains = insightSupport.filter((c) => c.enabled);
            // 3. ERC-20 balances for insight-enabled chains (batched 5 chains / call)
            let owned = [];
            let page = 0;
            const limit = 100;
            while (true) {
                const batch = await (0, get_tokens_js_1.getOwnedTokens)({
                    chains: insightEnabledChains.map((c) => c.chain),
                    client,
                    ownerAddress: wallet.getAccount()?.address || "",
                    queryOptions: {
                        limit,
                        metadata: "false",
                        page,
                    },
                });
                if (batch.length === 0) {
                    break;
                }
                // find matching origin token in allRoutes
                const tokensWithBalance = batch
                    .map((b) => ({
                    balance: b.value,
                    originAmount: 0n,
                    originToken: allOriginTokens.find((t) => t.address.toLowerCase() === b.tokenAddress.toLowerCase() &&
                        t.chainId === b.chainId),
                }))
                    .filter((t) => !!t.originToken);
                owned = [...owned, ...tokensWithBalance];
                page += 1;
            }
            const requiredDollarAmount = Number.parseFloat(destinationAmount) * destinationToken.priceUsd;
            // sort by dollar balance descending
            owned.sort((a, b) => {
                const aDollarBalance = Number.parseFloat((0, units_js_1.toTokens)(a.balance, a.originToken.decimals)) *
                    a.originToken.priceUsd;
                const bDollarBalance = Number.parseFloat((0, units_js_1.toTokens)(b.balance, b.originToken.decimals)) *
                    b.originToken.priceUsd;
                return bDollarBalance - aDollarBalance;
            });
            const suitableOriginTokens = [];
            for (const b of owned) {
                if (b.originToken && b.balance > 0n) {
                    const dollarBalance = Number.parseFloat((0, units_js_1.toTokens)(b.balance, b.originToken.decimals)) *
                        b.originToken.priceUsd;
                    if (b.originToken.priceUsd && dollarBalance < requiredDollarAmount) {
                        continue;
                    }
                    if (includeDestinationToken &&
                        b.originToken.address.toLowerCase() ===
                            destinationToken.address.toLowerCase() &&
                        b.originToken.chainId === destinationToken.chainId) {
                        // add same token to the front of the list
                        suitableOriginTokens.unshift({
                            balance: b.balance,
                            originAmount: 0n,
                            originToken: b.originToken,
                        });
                        continue;
                    }
                    suitableOriginTokens.push({
                        balance: b.balance,
                        originAmount: 0n,
                        originToken: b.originToken,
                    });
                }
            }
            const transformedRoutes = [
                ...suitableOriginTokens.map((s) => ({
                    balance: s.balance,
                    originToken: s.originToken,
                    payerWallet: wallet,
                    type: "wallet",
                })),
            ];
            return transformedRoutes;
        },
        queryKey: [
            "bridge-routes",
            destinationToken.chainId,
            destinationToken.address,
            destinationAmount,
            payerWallet?.getAccount()?.address,
            includeDestinationToken,
        ], // 5 minutes
        refetchOnWindowFocus: false,
        staleTime: 5 * 60 * 1000,
    });
    return {
        data: routesQuery.data || [],
        error: routesQuery.error,
        isError: routesQuery.isError,
        isLoading: routesQuery.isLoading,
        isSuccess: routesQuery.isSuccess,
        refetch: routesQuery.refetch,
    };
}
//# sourceMappingURL=usePaymentMethods.js.map