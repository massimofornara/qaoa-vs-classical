"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransferConfirmationScreen = TransferConfirmationScreen;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_icons_1 = require("@radix-ui/react-icons");
const react_query_1 = require("@tanstack/react-query");
const react_1 = require("react");
const pay_js_1 = require("../../../../../../../analytics/track/pay.js");
const utils_js_1 = require("../../../../../../../chains/utils.js");
const addresses_js_1 = require("../../../../../../../constants/addresses.js");
const contract_js_1 = require("../../../../../../../contract/contract.js");
const allowance_js_1 = require("../../../../../../../extensions/erc20/__generated__/IERC20/read/allowance.js");
const getCurrencyMetadata_js_1 = require("../../../../../../../extensions/erc20/read/getCurrencyMetadata.js");
const approve_js_1 = require("../../../../../../../extensions/erc20/write/approve.js");
const transfer_js_1 = require("../../../../../../../extensions/erc20/write/transfer.js");
const getTransfer_js_1 = require("../../../../../../../pay/buyWithCrypto/getTransfer.js");
const send_and_confirm_transaction_js_1 = require("../../../../../../../transaction/actions/send-and-confirm-transaction.js");
const send_transaction_js_1 = require("../../../../../../../transaction/actions/send-transaction.js");
const prepare_transaction_js_1 = require("../../../../../../../transaction/prepare-transaction.js");
const units_js_1 = require("../../../../../../../utils/units.js");
const index_js_1 = require("../../../../../../core/design-system/index.js");
const basic_js_1 = require("../../../../components/basic.js");
const buttons_js_1 = require("../../../../components/buttons.js");
const Spacer_js_1 = require("../../../../components/Spacer.js");
const Spinner_js_1 = require("../../../../components/Spinner.js");
const StepBar_js_1 = require("../../../../components/StepBar.js");
const SwitchNetwork_js_1 = require("../../../../components/SwitchNetwork.js");
const text_js_1 = require("../../../../components/text.js");
const nativeToken_js_1 = require("../../nativeToken.js");
const Stepper_js_1 = require("../Stepper.js");
const ConfirmationScreen_js_1 = require("./ConfirmationScreen.js");
const ErrorText_js_1 = require("./ErrorText.js");
const SwapSummary_js_1 = require("./SwapSummary.js");
function TransferConfirmationScreen(props) {
    const { title, onBack, receiverAddress, client, payer, onDone, chain, token, tokenAmount, transactionMode, setTransactionHash, payOptions, paymentLinkId, } = props;
    const [step, setStep] = (0, react_1.useState)("transfer");
    const [status, setStatus] = (0, react_1.useState)({ id: "idle" });
    const transferQuery = (0, react_query_1.useQuery)({
        queryFn: async () => {
            const transferResponse = await (0, getTransfer_js_1.getBuyWithCryptoTransfer)({
                amount: tokenAmount,
                chainId: chain.id,
                client,
                feePayer: payOptions?.mode === "direct_payment"
                    ? payOptions.paymentInfo.feePayer
                    : undefined,
                fromAddress: payer.account.address,
                paymentLinkId: paymentLinkId,
                purchaseData: payOptions?.purchaseData,
                toAddress: receiverAddress,
                tokenAddress: (0, nativeToken_js_1.isNativeToken)(token)
                    ? addresses_js_1.NATIVE_TOKEN_ADDRESS
                    : token.address,
            });
            return transferResponse;
        },
        queryKey: [
            "transfer",
            (0, nativeToken_js_1.isNativeToken)(token) ? addresses_js_1.NATIVE_TOKEN_ADDRESS : token.address,
            tokenAmount,
            receiverAddress,
            payer.account.address,
            payOptions?.purchaseData,
        ],
        refetchInterval: 30 * 1000,
    });
    const uiErrorMessage = (0, react_1.useMemo)(() => {
        if (step === "approve" && status.id === "error" && status.error) {
            if (status.error.toLowerCase().includes("user rejected") ||
                status.error.toLowerCase().includes("user closed modal") ||
                status.error.toLowerCase().includes("user denied")) {
                return {
                    message: "Your wallet rejected the approval request.",
                    title: "Failed to Approve",
                };
            }
            if (status.error.toLowerCase().includes("insufficient funds for gas")) {
                return {
                    message: "You do not have enough native funds to approve the transaction.",
                    title: "Insufficient Native Funds",
                };
            }
            return {
                message: "Your wallet failed to approve the transaction for an unknown reason. Please try again or contact support.",
                title: "Failed to Approve",
            };
        }
        if ((step === "transfer" || step === "execute") &&
            status.id === "error" &&
            status.error) {
            if (status.error.toLowerCase().includes("user rejected") ||
                status.error.toLowerCase().includes("user closed modal") ||
                status.error.toLowerCase().includes("user denied")) {
                return {
                    message: "Your wallet rejected the confirmation request.",
                    title: "Failed to Confirm",
                };
            }
            if (status.error.toLowerCase().includes("insufficient funds for gas")) {
                return {
                    message: "You do not have enough native funds to confirm the transaction.",
                    title: "Insufficient Native Funds",
                };
            }
            return {
                message: "Your wallet failed to confirm the transaction for an unknown reason. Please try again or contact support.",
                title: "Failed to Confirm",
            };
        }
        return undefined;
    }, [step, status]);
    if (transferQuery.isLoading) {
        return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { p: "lg", children: [(0, jsx_runtime_1.jsx)(basic_js_1.ModalHeader, { onBack: onBack, title: title }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { center: "both", flex: "column", style: { minHeight: "300px" }, children: [(0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xl" }), (0, jsx_runtime_1.jsx)(Spinner_js_1.Spinner, { color: "secondaryText", size: "xl" }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xl" })] })] }));
    }
    const transferFromAmountWithFees = transferQuery.data?.paymentToken.amount || tokenAmount;
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { p: "lg", children: [(0, jsx_runtime_1.jsx)(basic_js_1.ModalHeader, { onBack: onBack, title: title }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xl" }), transactionMode ? ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(StepBar_js_1.StepBar, { currentStep: step === "transfer" ? 1 : 2, steps: 2 }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "sm" }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "sm", children: step === "transfer"
                            ? "Step 1 of 2 - Transfer funds"
                            : "Step 2 of 2 - Finalize transaction" }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" })] })) : ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "sm", children: "Confirm payment" }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" })] })), (0, jsx_runtime_1.jsx)(SwapSummary_js_1.SwapSummary, { client: client, fromAmount: transactionMode ? tokenAmount : transferFromAmountWithFees, fromChain: chain, fromToken: token, receiver: receiverAddress, sender: payer.account.address, toAmount: tokenAmount, toChain: chain, toToken: token }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" }), transactionMode && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "sm" }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { center: "y", color: "accentText", flex: "row", gap: "sm", style: {
                            justifyContent: "space-between",
                        }, children: [(0, jsx_runtime_1.jsx)(Stepper_js_1.Step, { isActive: step === "transfer", isDone: step === "execute", label: step === "transfer" ? "Transfer" : "Done" }), (0, jsx_runtime_1.jsx)(ConfirmationScreen_js_1.ConnectorLine, {}), (0, jsx_runtime_1.jsx)(Stepper_js_1.Step, { isActive: step === "execute", isDone: false, label: "Finalize" })] }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" })] })), uiErrorMessage && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(ErrorText_js_1.ErrorText, { message: uiErrorMessage.message, title: uiErrorMessage.title }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" })] })), !transactionMode && step === "execute" && status.id === "done" && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsxs)(basic_js_1.Container, { center: "both", color: "success", flex: "row", gap: "xs", children: [(0, jsx_runtime_1.jsx)(react_icons_1.CheckCircledIcon, { height: index_js_1.iconSize.sm, width: index_js_1.iconSize.sm }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { color: "success", size: "sm", children: "Payment completed" })] }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" })] })), payer.chain.id !== chain.id ? ((0, jsx_runtime_1.jsx)(SwitchNetwork_js_1.SwitchNetworkButton, { fullWidth: true, switchChain: async () => {
                    await props.payer.wallet.switchChain(chain);
                }, variant: "accent" })) : ((0, jsx_runtime_1.jsxs)(buttons_js_1.Button, { disabled: status.id === "pending", fullWidth: true, gap: "xs", onClick: async () => {
                    if (step === "execute") {
                        onDone();
                        return;
                    }
                    try {
                        setStatus({ id: "pending" });
                        // TRANSACTION MODE = transfer funds to another one of your wallets before executing the tx
                        if (transactionMode) {
                            const transaction = (0, nativeToken_js_1.isNativeToken)(token)
                                ? (0, prepare_transaction_js_1.prepareTransaction)({
                                    chain,
                                    client,
                                    to: receiverAddress,
                                    value: (0, units_js_1.toWei)(tokenAmount),
                                })
                                : (0, transfer_js_1.transfer)({
                                    amount: tokenAmount,
                                    contract: (0, contract_js_1.getContract)({
                                        address: token.address,
                                        chain: chain,
                                        client: client,
                                    }),
                                    to: receiverAddress,
                                });
                            const [txResult, tokenMetadata] = await Promise.all([
                                (0, send_and_confirm_transaction_js_1.sendAndConfirmTransaction)({
                                    account: props.payer.account,
                                    transaction,
                                }),
                                (0, getCurrencyMetadata_js_1.getCurrencyMetadata)({
                                    contract: (0, contract_js_1.getContract)({
                                        address: (0, nativeToken_js_1.isNativeToken)(token)
                                            ? addresses_js_1.NATIVE_TOKEN_ADDRESS
                                            : token.address,
                                        chain: chain,
                                        client: client,
                                    }),
                                }),
                            ]);
                            (0, pay_js_1.trackPayEvent)({
                                client: props.client,
                                event: "transfer_confirmation_success_transaction_mode",
                                toChainId: chain.id,
                                toToken: (0, nativeToken_js_1.isNativeToken)(token) ? undefined : token.address,
                                walletAddress: payer.account.address,
                                walletType: payer.wallet.id,
                            });
                            // its the last step before the transaction, so propagate onPurchaseSuccess here
                            props.onSuccess?.(transferBuyWithCryptoQuote({
                                chain,
                                fromAddress: payer.account.address,
                                toAddress: receiverAddress,
                                token,
                                tokenAmount: transactionMode
                                    ? tokenAmount
                                    : transferFromAmountWithFees,
                                tokenMetadata,
                                transaction: txResult,
                            }));
                            // switch to execute step
                            setStep("execute");
                            setStatus({ id: "idle" });
                        }
                        else {
                            const transferResponse = transferQuery.data;
                            if (!transferResponse) {
                                throw new Error("Transfer data not found");
                            }
                            if (transferResponse.approvalData) {
                                // check allowance
                                const prevAllowance = await (0, allowance_js_1.allowance)({
                                    contract: (0, contract_js_1.getContract)({
                                        address: transferResponse.approvalData.tokenAddress,
                                        chain: (0, utils_js_1.getCachedChain)(transferResponse.approvalData.chainId),
                                        client: client,
                                    }),
                                    owner: payer.account.address,
                                    spender: transferResponse.approvalData
                                        .spenderAddress,
                                });
                                if (prevAllowance <
                                    BigInt(transferResponse.approvalData.amountWei)) {
                                    setStep("approve");
                                    (0, pay_js_1.trackPayEvent)({
                                        client: props.client,
                                        event: "prompt_transfer_approval",
                                        toChainId: chain.id,
                                        toToken: (0, nativeToken_js_1.isNativeToken)(token) ? undefined : token.address,
                                        walletAddress: payer.account.address,
                                        walletType: payer.wallet.id,
                                    });
                                    const transaction = (0, approve_js_1.approve)({
                                        amountWei: BigInt(transferResponse.approvalData.amountWei),
                                        contract: (0, contract_js_1.getContract)({
                                            address: transferResponse.approvalData.tokenAddress,
                                            chain: (0, utils_js_1.getCachedChain)(transferResponse.approvalData.chainId),
                                            client: client,
                                        }),
                                        spender: transferResponse.approvalData
                                            .spenderAddress,
                                    });
                                    // approve the transfer
                                    await (0, send_and_confirm_transaction_js_1.sendAndConfirmTransaction)({
                                        account: props.payer.account,
                                        transaction,
                                    });
                                    (0, pay_js_1.trackPayEvent)({
                                        client: props.client,
                                        event: "transfer_approval_success",
                                        toChainId: chain.id,
                                        toToken: (0, nativeToken_js_1.isNativeToken)(token) ? undefined : token.address,
                                        walletAddress: payer.account.address,
                                        walletType: payer.wallet.id,
                                    });
                                }
                            }
                            (0, pay_js_1.trackPayEvent)({
                                client: props.client,
                                event: "prompt_transfer_confirmation",
                                toChainId: chain.id,
                                toToken: (0, nativeToken_js_1.isNativeToken)(token) ? undefined : token.address,
                                walletAddress: payer.account.address,
                                walletType: payer.wallet.id,
                            });
                            setStep("transfer");
                            // execute the transfer
                            const transaction = transferResponse.transactionRequest;
                            const tx = await (0, send_transaction_js_1.sendTransaction)({
                                account: props.payer.account,
                                transaction,
                            });
                            // switches to the status polling screen
                            setTransactionHash(tx.transactionHash);
                            setStatus({ id: "idle" });
                            (0, pay_js_1.trackPayEvent)({
                                client: props.client,
                                event: "transfer_confirmation_success",
                                toChainId: chain.id,
                                toToken: (0, nativeToken_js_1.isNativeToken)(token) ? undefined : token.address,
                                walletAddress: payer.account.address,
                                walletType: payer.wallet.id,
                            });
                        }
                        // biome-ignore lint/suspicious/noExplicitAny: catch multiple errors
                    }
                    catch (e) {
                        console.error(e);
                        setStatus({
                            error: "error" in e ? e.error?.message : e?.message,
                            id: "error",
                        });
                    }
                }, variant: "accent", children: [step === "execute" && (status.id === "done" ? "Done" : "Continue"), step === "transfer" &&
                        (status.id === "pending" ? "Confirming" : "Confirm"), step === "approve" &&
                        (status.id === "pending" ? "Approving" : "Approve"), status.id === "pending" && ((0, jsx_runtime_1.jsx)(Spinner_js_1.Spinner, { color: "accentButtonText", size: "sm" }))] }))] }));
}
function transferBuyWithCryptoQuote(args) {
    const { token, chain, tokenMetadata, tokenAmount, fromAddress, toAddress, transaction, } = args;
    return {
        fromAddress,
        quote: {
            createdAt: new Date().toISOString(),
            estimated: {
                durationSeconds: 0,
                feesUSDCents: 0,
                fromAmountUSDCents: 0,
                gasCostUSDCents: 0,
                slippageBPS: 0,
                toAmountMinUSDCents: 0,
                toAmountUSDCents: 0,
            },
            fromAmount: tokenAmount,
            fromAmountWei: (0, units_js_1.toWei)(tokenAmount).toString(),
            fromToken: {
                chainId: chain.id,
                decimals: tokenMetadata.decimals,
                name: tokenMetadata.name,
                priceUSDCents: 0,
                symbol: tokenMetadata.symbol,
                tokenAddress: (0, nativeToken_js_1.isNativeToken)(token)
                    ? addresses_js_1.NATIVE_TOKEN_ADDRESS
                    : token.address,
            },
            toAmount: tokenAmount,
            toAmountMin: tokenAmount,
            toAmountMinWei: (0, units_js_1.toWei)(tokenAmount).toString(),
            toAmountWei: (0, units_js_1.toWei)(tokenAmount).toString(),
            toToken: {
                chainId: chain.id,
                decimals: tokenMetadata.decimals,
                name: tokenMetadata.name,
                priceUSDCents: 0,
                symbol: tokenMetadata.symbol,
                tokenAddress: (0, nativeToken_js_1.isNativeToken)(token)
                    ? addresses_js_1.NATIVE_TOKEN_ADDRESS
                    : token.address,
            },
        },
        source: {
            amount: tokenAmount,
            amountUSDCents: 0,
            amountWei: (0, units_js_1.toWei)(tokenAmount).toString(),
            completedAt: new Date().toISOString(),
            token: {
                chainId: chain.id,
                decimals: tokenMetadata.decimals,
                name: tokenMetadata.name,
                priceUSDCents: 0,
                symbol: tokenMetadata.symbol,
                tokenAddress: (0, nativeToken_js_1.isNativeToken)(token)
                    ? addresses_js_1.NATIVE_TOKEN_ADDRESS
                    : token.address,
            },
            transactionHash: transaction.transactionHash,
        },
        status: "COMPLETED",
        subStatus: "SUCCESS",
        swapType: "TRANSFER",
        toAddress,
    };
}
//# sourceMappingURL=TransferConfirmationScreen.js.map