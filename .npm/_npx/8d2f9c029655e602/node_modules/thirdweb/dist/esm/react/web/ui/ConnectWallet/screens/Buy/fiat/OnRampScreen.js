import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useCallback, useEffect, useRef, useState } from "react";
import { trackPayEvent } from "../../../../../../../analytics/track/pay.js";
import { getCachedChain } from "../../../../../../../chains/utils.js";
import { getContract } from "../../../../../../../contract/contract.js";
import { allowance } from "../../../../../../../extensions/erc20/__generated__/IERC20/read/allowance.js";
import { approve } from "../../../../../../../extensions/erc20/write/approve.js";
import { getBuyWithCryptoQuote } from "../../../../../../../pay/buyWithCrypto/getQuote.js";
import { getBuyWithFiatStatus, } from "../../../../../../../pay/buyWithFiat/getStatus.js";
import { getOnRampSteps, } from "../../../../../../../pay/buyWithFiat/isSwapRequiredPostOnramp.js";
import { sendBatchTransaction } from "../../../../../../../transaction/actions/send-batch-transaction.js";
import { sendTransaction } from "../../../../../../../transaction/actions/send-transaction.js";
import { waitForReceipt } from "../../../../../../../transaction/actions/wait-for-tx-receipt.js";
import { formatNumber } from "../../../../../../../utils/formatNumber.js";
import { isInAppSigner } from "../../../../../../../wallets/in-app/core/wallet/is-in-app-signer.js";
import { spacing } from "../../../../../../core/design-system/index.js";
import { useChainName } from "../../../../../../core/hooks/others/useChainQuery.js";
import { useBuyWithCryptoStatus } from "../../../../../../core/hooks/pay/useBuyWithCryptoStatus.js";
import { useBuyWithFiatStatus } from "../../../../../../core/hooks/pay/useBuyWithFiatStatus.js";
import { useConnectedWallets } from "../../../../../../core/hooks/wallets/useConnectedWallets.js";
import { invalidateWalletBalance } from "../../../../../../core/providers/invalidateWalletBalance.js";
import { Container, ModalHeader } from "../../../../components/basic.js";
import { Button } from "../../../../components/buttons.js";
import { Spacer } from "../../../../components/Spacer.js";
import { Spinner } from "../../../../components/Spinner.js";
import { SwitchNetworkButton } from "../../../../components/SwitchNetwork.js";
import { Text } from "../../../../components/text.js";
import { TokenSymbol } from "../../../../components/token/TokenSymbol.js";
import { openOnrampPopup } from "../openOnRamppopup.js";
import { PayTokenIcon } from "../PayTokenIcon.js";
import { addPendingTx } from "../swap/pendingSwapTx.js";
import { StepConnectorArrow } from "../swap/StepConnector.js";
import { WalletRow } from "../swap/WalletRow.js";
import { getProviderLabel } from "../utils.js";
import { StepContainer } from "./FiatSteps.js";
export function OnRampScreen(props) {
    const connectedWallets = useConnectedWallets();
    const isAutoMode = isInAppSigner({
        connectedWallets,
        wallet: props.payer.wallet,
    });
    const state = useOnRampScreenState({
        client: props.client,
        isAutoMode,
        onDone: props.onDone,
        onSuccess: props.onSuccess,
        payer: props.payer,
        paymentLinkId: props.paymentLinkId,
        quote: props.quote,
        theme: props.theme,
    });
    const firstStepChainId = state.steps[0]?.step.token.chainId;
    return (_jsxs(Container, { p: "lg", children: [_jsx(ModalHeader, { onBack: props.onBack, title: props.title }), _jsx(Spacer, { y: "xl" }), _jsx(Container, { center: "y", flex: "column", gap: "xs", style: {
                    paddingLeft: spacing.md,
                }, children: _jsx(WalletRow, { address: props.receiverAddress, client: props.client, iconSize: "md", label: "Recipient wallet", textSize: "sm" }) }), _jsx(Spacer, { y: "md" }), _jsx(Container, { flex: "column", children: state.steps.map(({ step, status }, index) => (_jsxs(Container, { flex: "column", children: [_jsx(StepContainer, { index: index, state: status, style: {
                                flex: "1",
                            }, children: _jsx(StepUI, { client: props.client, index: index, payer: props.payer, step: step }) }), index < state.steps.length - 1 && _jsx(StepConnectorArrow, {})] }, step.action))) }), _jsx(Spacer, { y: "md" }), _jsx(Text, { center: true, color: "secondaryText", size: "xs", style: { padding: `0 ${spacing.xl}` }, children: "Keep this window open until all transactions are complete." }), _jsx(Spacer, { y: "lg" }), _jsx(Container, { flex: "column", gap: "md", children: !state.isDone &&
                    firstStepChainId &&
                    firstStepChainId !== props.payer.chain.id ? (_jsx(SwitchNetworkButton, { fullWidth: true, switchChain: async () => {
                        await props.payer.wallet.switchChain(getCachedChain(firstStepChainId));
                    }, variant: "accent" })) : (_jsxs(Button, { disabled: state.isLoading, fullWidth: true, gap: "sm", onClick: state.handleContinue, variant: "accent", children: [state.isLoading
                            ? "Processing"
                            : state.isDone
                                ? props.transactionMode
                                    ? "Continue Transaction"
                                    : "Done"
                                : state.isFailed
                                    ? "Retry"
                                    : "Continue", state.isLoading && _jsx(Spinner, { color: "primaryText", size: "sm" })] })) })] }));
}
function StepUI(props) {
    const { step, client } = props;
    const chain = useChainName(getCachedChain(step.token.chainId));
    return (_jsx(Container, { flex: "column", gap: "xs", py: "3xs", children: _jsxs(Container, { center: "y", flex: "row", gap: "sm", style: {
                display: "flex",
                flexWrap: "nowrap",
                justifyContent: "space-between",
            }, children: [_jsx(PayTokenIcon, { chain: getCachedChain(step.token.chainId), client: client, size: "md", token: {
                        address: step.token.tokenAddress,
                    } }), _jsxs(Container, { center: "y", flex: "column", gap: "3xs", style: { flex: "1" }, children: [_jsx(Text, { color: "primaryText", size: "sm", children: getProviderLabel(step.action) }), _jsxs(Container, { center: "y", flex: "row", gap: "xs", style: {
                                display: "flex",
                                flexWrap: "nowrap",
                                justifyContent: "space-between",
                            }, children: [_jsxs(Container, { center: "y", flex: "row", gap: "xxs", style: {
                                        flex: "1 1 60%",
                                        flexWrap: "nowrap",
                                        maxWidth: "60%",
                                        minWidth: 0,
                                        overflow: "hidden",
                                    }, children: [_jsx(Text, { color: "primaryText", size: "sm", children: formatNumber(Number(step.amount), 5) }), _jsx(TokenSymbol, { chain: getCachedChain(step.token.chainId), color: "secondaryText", size: "sm", token: {
                                                address: step.token.tokenAddress,
                                                name: step.token.name || "",
                                                symbol: step.token.symbol || "",
                                            } })] }), _jsx(Container, { center: "y", flex: "row", gap: "xs", style: {
                                        flex: "1 1 40%",
                                        flexWrap: "nowrap",
                                        justifyContent: "flex-end",
                                        maxWidth: "40%",
                                        minWidth: 0,
                                    }, children: _jsx(Text, { size: "xs", style: {
                                            overflow: "hidden",
                                            textOverflow: "ellipsis",
                                            whiteSpace: "nowrap",
                                        }, children: chain.name }) })] })] })] }) }));
}
function useOnRampScreenState(props) {
    const onRampSteps = getOnRampSteps(props.quote);
    const [currentStepIndex, setCurrentStepIndex] = useState(0);
    const [swapTxHash, setSwapTxHash] = useState();
    const [popupWindow, setPopupWindow] = useState(null);
    // Track onramp status
    const { uiStatus: fiatOnrampStatus } = useOnRampStatus({
        client: props.client,
        intentId: props.quote.intentId,
        onSuccess: (status) => {
            if (onRampSteps.length === 1) {
                // If only one step, this is the final success
                props.onSuccess(status);
            }
            else {
                // Move to next step (swap)
                setCurrentStepIndex((prev) => prev + 1);
            }
        },
        openedWindow: popupWindow,
    });
    // Get quote for current swap/bridge step if needed
    const previousStep = onRampSteps[currentStepIndex - 1];
    const currentStep = onRampSteps[currentStepIndex];
    // Handle swap execution
    const swapMutation = useSwapMutation({
        client: props.client,
        isFiatFlow: true,
        payer: props.payer,
        paymentLinkId: props.paymentLinkId,
    });
    // Track swap status
    const { uiStatus: swapStatus } = useSwapStatus({
        chainId: swapTxHash?.chainId,
        client: props.client,
        onSuccess: () => {
            if (currentStepIndex === onRampSteps.length - 1) {
                // Last step completed - call final success
                getBuyWithFiatStatus({
                    client: props.client,
                    intentId: props.quote.intentId,
                }).then(props.onSuccess);
            }
            else {
                // Reset swap state before moving to next step
                setSwapTxHash(undefined);
                swapMutation.reset();
                // Move to next step
                setCurrentStepIndex((prev) => prev + 1);
            }
        },
        transactionHash: swapTxHash?.hash,
    });
    // Map steps to their current status
    const steps = onRampSteps.map((step, index) => {
        let status = "unknown";
        if (index === 0) {
            // First step (onramp) status
            status = fiatOnrampStatus;
        }
        else if (index < currentStepIndex) {
            // Previous steps are completed
            status = "completed";
        }
        else if (index === currentStepIndex) {
            // Current step - could be swap or bridge
            if (swapMutation.isPending) {
                status = "pending";
            }
            else if (swapMutation.error) {
                status = "failed";
            }
            else if (swapTxHash) {
                status = swapStatus;
            }
            else {
                status = "actionRequired";
            }
        }
        return {
            index,
            status,
            step,
        };
    });
    const isLoading = steps.some((step) => step.status === "pending");
    const isDone = steps.every((step) => step.status === "completed");
    const isFailed = steps.some((step) => step.status === "failed");
    // Update handleContinue to handle done state
    const handleContinue = useCallback(async () => {
        if (isDone) {
            props.onDone();
            return;
        }
        if (currentStepIndex === 0) {
            // First step - open onramp popup
            const popup = openOnrampPopup(props.quote.onRampLink, props.theme);
            trackPayEvent({
                amountWei: props.quote.onRampToken.amountWei,
                client: props.client,
                event: "open_onramp_popup",
                toChainId: props.quote.onRampToken.token.chainId,
                toToken: props.quote.onRampToken.token.tokenAddress,
                walletAddress: props.payer.account.address,
                walletType: props.payer.wallet.id,
            });
            setPopupWindow(popup);
            addPendingTx({
                intentId: props.quote.intentId,
                type: "fiat",
            });
        }
        else if (previousStep && currentStep && !swapTxHash) {
            // Execute swap/bridge
            try {
                const result = await swapMutation.mutateAsync({
                    amount: currentStep.amount,
                    fromToken: previousStep.token,
                    toToken: currentStep.token,
                });
                setSwapTxHash({
                    chainId: result.chainId,
                    hash: result.transactionHash,
                });
            }
            catch (e) {
                console.error("Failed to execute swap:", e);
            }
        }
        else if (isFailed) {
            // retry the quote step
            setSwapTxHash(undefined);
            swapMutation.reset();
        }
    }, [
        isDone,
        currentStepIndex,
        swapTxHash,
        props.quote,
        props.onDone,
        swapMutation,
        props.theme,
        isFailed,
        swapMutation.reset,
        props.client,
        props.payer.account.address,
        props.payer.wallet.id,
        currentStep,
        previousStep,
    ]);
    // Auto-progress effect
    useEffect(() => {
        if (!props.isAutoMode) {
            return;
        }
        // Auto-start next swap step when previous step completes
        if (!isLoading &&
            !isDone &&
            !isFailed &&
            currentStepIndex > 0 &&
            currentStepIndex < onRampSteps.length &&
            !swapTxHash) {
            handleContinue();
        }
    }, [
        props.isAutoMode,
        currentStepIndex,
        swapTxHash,
        onRampSteps.length,
        handleContinue,
        isDone,
        isFailed,
        isLoading,
    ]);
    return {
        handleContinue,
        isDone,
        isFailed,
        isLoading,
        steps,
    };
}
function useOnRampStatus(props) {
    const queryClient = useQueryClient();
    const statusQuery = useBuyWithFiatStatus({
        client: props.client,
        intentId: props.intentId,
        queryOptions: {
            enabled: !!props.openedWindow,
        },
    });
    let uiStatus = "actionRequired";
    switch (statusQuery.data?.status) {
        case "ON_RAMP_TRANSFER_COMPLETED":
            uiStatus = "completed";
            break;
        case "PAYMENT_FAILED":
            uiStatus = "failed";
            break;
        case "PENDING_PAYMENT":
            uiStatus = "pending";
            break;
        default:
            uiStatus = "actionRequired";
            break;
    }
    const purchaseCbCalled = useRef(false);
    useEffect(() => {
        if (purchaseCbCalled.current || !props.onSuccess) {
            return;
        }
        if (statusQuery.data && uiStatus === "completed") {
            purchaseCbCalled.current = true;
            props.onSuccess(statusQuery.data);
        }
    }, [props.onSuccess, statusQuery.data, uiStatus]);
    // close the onramp popup if onramp is completed
    useEffect(() => {
        if (!props.openedWindow) {
            return;
        }
        if (uiStatus === "completed") {
            try {
                if (props.openedWindow && !props.openedWindow.closed) {
                    props.openedWindow.close();
                }
            }
            catch (e) {
                console.warn("Failed to close payment window:", e);
            }
        }
    }, [props.openedWindow, uiStatus]);
    // invalidate wallet balance when onramp is completed
    const invalidatedBalance = useRef(false);
    useEffect(() => {
        if (!invalidatedBalance.current && uiStatus === "completed") {
            invalidatedBalance.current = true;
            invalidateWalletBalance(queryClient);
        }
    }, [uiStatus, queryClient]);
    return { uiStatus };
}
function useSwapStatus(props) {
    const swapStatus = useBuyWithCryptoStatus(props.transactionHash && props.chainId
        ? {
            chainId: props.chainId,
            client: props.client,
            transactionHash: props.transactionHash,
        }
        : undefined);
    let uiStatus = "unknown";
    switch (swapStatus.data?.status) {
        case "COMPLETED":
            uiStatus = "completed";
            break;
        case "FAILED":
            uiStatus = "failed";
            break;
        case "PENDING":
        case "NOT_FOUND":
            uiStatus = "pending";
            break;
        case "NONE":
            uiStatus = "unknown";
            break;
        default:
            uiStatus = "unknown";
            break;
    }
    const purchaseCbCalled = useRef(false);
    useEffect(() => {
        if (purchaseCbCalled.current || !props.onSuccess) {
            return;
        }
        if (swapStatus.data?.status === "COMPLETED") {
            purchaseCbCalled.current = true;
            props.onSuccess(swapStatus.data);
        }
    }, [props.onSuccess, swapStatus]);
    const queryClient = useQueryClient();
    const balanceInvalidated = useRef(false);
    useEffect(() => {
        if (uiStatus === "completed" && !balanceInvalidated.current) {
            balanceInvalidated.current = true;
            invalidateWalletBalance(queryClient);
        }
    }, [queryClient, uiStatus]);
    return { uiStatus };
}
function useSwapMutation(props) {
    const queryClient = useQueryClient();
    return useMutation({
        mutationFn: async (input) => {
            const { fromToken, toToken, amount } = input;
            const wallet = props.payer.wallet;
            // in case the wallet is not on the same chain as the fromToken, switch to it
            if (wallet.getChain()?.id !== fromToken.chainId) {
                await wallet.switchChain(getCachedChain(fromToken.chainId));
            }
            const account = wallet.getAccount();
            if (!account) {
                throw new Error("Payer wallet has no account");
            }
            // always get a fresh quote before executing
            const quote = await getBuyWithCryptoQuote({
                client: props.client,
                fromAddress: account.address,
                fromChainId: fromToken.chainId,
                fromTokenAddress: fromToken.tokenAddress,
                paymentLinkId: props.paymentLinkId,
                toAddress: account.address,
                toAmount: amount,
                toChainId: toToken.chainId,
                toTokenAddress: toToken.tokenAddress,
            });
            const canBatch = account.sendBatchTransaction;
            const tokenContract = getContract({
                address: quote.swapDetails.fromToken.tokenAddress,
                chain: getCachedChain(quote.swapDetails.fromToken.chainId),
                client: props.client,
            });
            const approveTxRequired = quote.approvalData &&
                (await allowance({
                    contract: tokenContract,
                    owner: account.address,
                    spender: quote.approvalData.spenderAddress,
                })) < BigInt(quote.approvalData.amountWei);
            if (approveTxRequired && quote.approvalData && !canBatch) {
                trackPayEvent({
                    amountWei: quote.swapDetails.fromAmountWei,
                    chainId: quote.swapDetails.fromToken.chainId,
                    client: props.client,
                    event: "prompt_swap_approval",
                    fromToken: quote.swapDetails.fromToken.tokenAddress,
                    toChainId: quote.swapDetails.toToken.chainId,
                    toToken: quote.swapDetails.toToken.tokenAddress,
                    walletAddress: account.address,
                    walletType: props.payer.wallet.id,
                });
                const transaction = approve({
                    amountWei: BigInt(quote.approvalData.amountWei),
                    contract: tokenContract,
                    spender: quote.approvalData.spenderAddress,
                });
                const tx = await sendTransaction({
                    account,
                    transaction,
                });
                await waitForReceipt({ ...tx, maxBlocksWaitTime: 50 });
                trackPayEvent({
                    amountWei: quote.swapDetails.fromAmountWei,
                    chainId: quote.swapDetails.fromToken.chainId,
                    client: props.client,
                    event: "swap_approval_success",
                    fromToken: quote.swapDetails.fromToken.tokenAddress,
                    toChainId: quote.swapDetails.toToken.chainId,
                    toToken: quote.swapDetails.toToken.tokenAddress,
                    walletAddress: account.address,
                    walletType: props.payer.wallet.id,
                });
            }
            trackPayEvent({
                amountWei: quote.swapDetails.fromAmountWei,
                chainId: quote.swapDetails.fromToken.chainId,
                client: props.client,
                event: "prompt_swap_execution",
                fromToken: quote.swapDetails.fromToken.tokenAddress,
                toChainId: quote.swapDetails.toToken.chainId,
                toToken: quote.swapDetails.toToken.tokenAddress,
                walletAddress: account.address,
                walletType: props.payer.wallet.id,
            });
            const tx = quote.transactionRequest;
            let _swapTx;
            // check if we can batch approval and swap
            if (canBatch && quote.approvalData && approveTxRequired) {
                const approveTx = approve({
                    amountWei: BigInt(quote.approvalData.amountWei),
                    contract: tokenContract,
                    spender: quote.approvalData.spenderAddress,
                });
                _swapTx = await sendBatchTransaction({
                    account,
                    transactions: [approveTx, tx],
                });
            }
            else {
                _swapTx = await sendTransaction({
                    account,
                    transaction: tx,
                });
            }
            await waitForReceipt({ ..._swapTx, maxBlocksWaitTime: 50 });
            trackPayEvent({
                amountWei: quote.swapDetails.fromAmountWei,
                chainId: quote.swapDetails.fromToken.chainId,
                client: props.client,
                event: "swap_execution_success",
                fromToken: quote.swapDetails.fromToken.tokenAddress,
                toChainId: quote.swapDetails.toToken.chainId,
                toToken: quote.swapDetails.toToken.tokenAddress,
                walletAddress: account.address,
                walletType: props.payer.wallet.id,
            });
            // do not add pending tx if the swap is part of fiat flow
            if (!props.isFiatFlow) {
                addPendingTx({
                    chainId: _swapTx.chain.id,
                    txHash: _swapTx.transactionHash,
                    type: "swap",
                });
            }
            return {
                chainId: _swapTx.chain.id,
                transactionHash: _swapTx.transactionHash,
            };
        },
        onSuccess: () => {
            invalidateWalletBalance(queryClient);
        },
    });
}
//# sourceMappingURL=OnRampScreen.js.map